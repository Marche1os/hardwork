### 2 примера ошибок нарушения предусловия

**Пример 1**

```kotlin
/**
 * Рассчитывает итоговую цену с учетом скидки.
 * {Предусловие: [basePrice] > 0, Постусловие: finalPrice > 0}
 */
fun calculateFinalPrice(basePrice: Double, discount: Double): Double {
    require(basePrice > 0) { "Базовая цена должна быть положительной" }
    
    val finalPrice = basePrice * (1 - discount)
    return if (finalPrice > 0) finalPrice else 0.01 // гарантия, что цена не станет нулевой или отрицательной
}

fun main() {
    try {
        // вызывающий код нарушает предусловие
        val finalPrice = calculateFinalPrice(-50.0, 0.1)
        println("Итоговая цена: $finalPrice")
    } catch (e: IllegalArgumentException) {
        println("Ошибка вызова: ${e.message}") 
        // Базовая цена должна быть положительной
    }
}
```

Функция `calculateFinalPrice` содержит инвариант, что basePrice положительна. 
Однако ошибка находится в коде, который его вызывает. 
Он передает отрицательное значение, нарушая контракт. Модульные рассуждения ломаются, потому что вызывающий код не выполнил свою часть сделки.

**Пример 2**

```kotlin
/**
 * Возвращает список сторис с видео
 * 
 * {Предусловие: [stories.isNotEmpty], Постусловие: [storyIds.isNotEmpty] }
 */
fun fetchVideoStoryIds(stories: List<Story>): List<String> {
    require(stories.isNotEmpty()) { "Список сторис не должен быть пустым" }
    
    val storyIds = stories.filter { it.isVideo }.map { it.id }
    
    // Допустим, мы уверены, что хотя бы одно видео в сторис всегда есть
    // если входной список не пуст
    check(storyIds.isNotEmpty()) { "В списке нет ни одного видео" } 
    
    return storyIds
}

// А Вызывающий код передает пустой список, нарушая предусловие
try {
    fetchVideoStoryIds(emptyList())
} catch (e: IllegalArgumentException) {
    println("Ошибка: ${e.message}")
    // Вывод: Список не должен быть пустым
}
```

Здесь вызывающий код передает пустой список, что противоречит предусловию. 
Функция fetchVideoStoryIds справедливо бросает исключение, так как ее контракт был нарушен.

### Примеры нарушения постусловия

**Пример 1**

```kotlin
/**
 * Предусловие: numbers != null
 * Постусловие: все элементы в результате >= 0
 */
fun filterNegativeNumbers(numbers: List<Int>): List<Int> {
    // Ошибка: используется `filter`, но результат не присваивается
    // Эта функция всегда будет возвращать исходный список
    val positiveNumbers = mutableListOf<Int>()
    for (number in numbers) {
        if (number >= 0) {
            // все хорошо
        } else {
            positiveNumbers.add(number) // Случайно добавили отрицательное число
        }
    }
    // Правильно было бы: return numbers.filter { it >= 0 }
    return positiveNumbers // Возвращаем список с ошибкой
}

fun main() {
    val input = listOf(10, -5, 20, -1)
    
    // предусловие соблюдено (список не null)
    val result = filterNegativeNumbers(input)
    
    // поверяем постусловие
    if (result.any { it < 0 }) {
        // нарушение постусловия
    }
}
```

Вызывающий код передал корректные данные. 
Однако из-за бага внутри `filterNegativeNumbers` она вернула список, содержащий отрицательные числа. 
Это нарушение ее собственного обещания (постусловия). 
Любой другой модуль, который доверяет этой функции, может дать сбой.

**Пример 2**

```kotlin
/**
 * Увеличивает значение и возвращает его.
 * Предусловие value >= 0
 * Постусловие result > 0
 */
fun incrementAndGet(value: Int): Int {
    // Предусловие соблюдено, но реализация хрупкая
    return value + 1
}

fun main() {
    val counter = Int.MAX_VALUE 
    
    // Предусловие (counter >= 0) соблюдено
    val newCounter = incrementAndGet(counter)
    
    // Проверка постусловия
    if (newCounter <= 0) {
        println("Нарушено постусловие, значение стало отрицательным: $newCounter")
    }
}
```

Вызывающий код передал валидное значение Int.MAX_VALUE. 
Но функция `incrementAndGet` не учла возможность целочисленного переполнения, из-за чего value + 1 стало отрицательным числом. 
Таким образом, функция нарушила свое постусловие result > 0.
Это похоже на пример бага из популярной книги, где баг был найден в следствие развития ИТ-систем в целом

### Принцип Постела

От либерализма в обработке стараемся отходить. 
Пару дней назад реализовал для одной части подсистемы коммуникацию через модель сообщений, одно из сообщение предназначено для открытия веб-ссылки и принимает `Uri`. 
В конструкторе такого сообщения содержится проверка, что схема у `Uri` = http|https. 
Ранее мы могли бы открыть просто битую ссылку, сейчас строго проверяем формат и выбросим `IllegalStateException` в случае нарушения контракта.

Также есть другой пример в проекте, это отправка performance метрик. 
Теоретически на старте приложенеия возможна ситуация отправки события до момента инициализации системы аналитики.
В таком случае событие просто не отправится и никакого оповещения, что отправить событие не удалось, не будет.
Это хрупкое место источник непрозрачности и может приводить к долгой отладке в поиске теряющихся событий.
Если бы была проверка контракта, это проблему удалось бы быстро поймать.

### Общение на уровне спецификаций

Эффект от такого общения

1. Проблема локализуется мгновенно. Мы не тратим время на отладку, а сразу обращаемся к спецификации. Разговор идет о фактах, а не о мнениях;
2. Сразу становится ясно, на чьей стороне ошибка. Это устраняет споры и взаимные обвинения;
3. Такое общение мотивирует всех участников писать код, ориентированный на контракты. Разработчики начинают лучше документировать свои функции, добавлять проверки (require, check) и задумываться о пограничных случаях;

По крайней мере 3 разработчика прониклись идеей и на новом коде на ПРах видно, как подход на контрактах потихоньку внедряется в проект.

### Выводы

Одним из основных положительных эффектов от выполнения задания - это принцип Постела. Прочитал статью о Microsoft.
Ранее по-умолчанию считал, что одно из свойств надежных систем это умение обрабатывать некорректные данные и с ними как-то работать.
Теперь категорически согласен, что заведомо некорректные данные нужно обрубать. 
Такой подход сильно поможет в дальнейшем развитии системы при соблюдении силы предусловия.

Упражнение по общению на уровне спецификаций заставило меня задуматься о качестве коммуникации в разработке. 
Я понял, что это не просто "софт-скилл", а фундаментальный инженерный навык. 
Обсуждение на уровне контрактов экономит огромное количество времени, переводя диалог из плоскости "у меня не работает" в "давай проверим, соблюдены ли все условия нашего соглашения". 
Этот подход устраняет двусмысленность и делает взаимодействие между разработчиками предсказуемым и эффективным.
