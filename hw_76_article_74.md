### 1

```kotlin
fun setSafeText(view: TextView?, text: String?) {
    // Предусловие ослаблено: допускается null и у view, и у text
    // Постусловие усилено: функция не крешится и всегда оставляет UI в согласованном состоянии
    view?.text = text ?: "Нет данных"
}
```
Убрана необходимость проверять оба параметра заранее, перед вызовом.

### 2

```kotlin
fun safeToInt(value: String?): Int {
    // Предусловие ослаблено: допускается null и некорректный ввод
    // Постусловие усилено: всегда возвращает число, не выбрасывает исключение
    return value?.toIntOrNull() ?: 0
}
```

Раньше была зависимость от корректности строки, теперь функция полностью безопасна.

### 3

```kotlin
fun calculateDiscount(price: Double, discountPercent: Int): Double {
    // Ослаблено: скидка может быть за пределами 0–100
    // Усилено: возвращается корректное значение, ограниченное диапазоном
    val normalized = discountPercent.coerceIn(0, 100)
    return price * (1 - normalized / 100.0)
}
```
Ранее требовалось, чтобы входные параметры были в нужных диапазонах. 
Сейчас постусловие гарантирует, что выходное значение в нужных диапазонах.

### 4

```kotlin
fun readTextOrEmpty(file: File): String {
    // Ослаблено: файл может не существовать
    // Усилено: всегда возвращается строка, исключений нет
    return if (file.exists() && file.canRead()) file.readText() else ""
}
```

раньше предусловие - "файл существует и читаем". Теперь функция сама проверяет это.

### 5

```kotlin
fun getItemSafely(list: List<String>, index: Int): String {
    // Ослаблено: индекс может быть любым (не требуется проверка до вызова)
    // Усилено: возвращается безопасное значение, без исключительной ситуации
    return if (index in list.indices) list[index] else "Пусто"
}
```

раньше требовалось, чтобы индекс был в допустимых пределах. Сейчас функция сама обрабатывает ошибку.

### Выводы

Выполняя это задание, я глубже понял, насколько важна концепция предусловий и постусловий при проектировании функций/класс. 
Я осознал, что ослабление предусловий помогает сделать код более гибким и устойчивым к ошибкам, а усиление постусловий повышает надежность. 
Этот подход учит писать код, способный корректно обрабатывать исключительные ситуации без сбоев.

В процессе работы я научился четче формулировать требования к функциям и понимать, какие предпосылки можно безопасно упростить. 
Также я увидел, как важно заранее продумывать поведение программы при ошибочных данных и возвращать ожидаемые результаты.

Теперь я понимаю, что применение этих принципов не только повышает качество кода, но и облегчает его поддержку. 
В реальной работе это поможет мне быстрее находить слабые места в логике. 
В целом, задание показало мне практическую ценность теоретических основ надежного программирования.