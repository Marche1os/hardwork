1. **Зависимость фреймворка.** На проекте есть зависимость в смысле подключенной библиотеки. Но если спуститься на уровень кода, вызывающего методы RxJava, то зависимости в вызове функций библиотеки здесь нет, так как наш результат не зависит от выполнения, результат по-сути задается вызывающим кодом. К сожалению, на проекте есть технический стрим по избавлению от зависимости (в смысле подключаемой библиотеки) RxJava. Добавлю еще пример в тему, есть фреймворк Unity, он предоставляет возможности небольшим командам разрабатывать свои игры. В один момент компания-владелец фреймворка решила брать деньги за каждую установку игры, разработанную на их фреймворке. Вот в таком примере зависимость значит, когда одна благополучие одной компании зависит от решений другой, хотя все начиналось как просто использование фреймворка.     
2. **Зависимость расшаренного формата.** На учебном проекте была задача записать в файл таблицу, где каждая колонка занимает определенно число байт. Соответственно результат работы Reader из этого файла зависит, соответствует ли шаблон данных в файле оговоренному. Зависимость здесь очевидная, поэтому разрешение зависимости тоже становится осознанным. **Решение:** интуитивно кажется, что нужно придумать какое-то связующее звено между Reader и Writer, чтобы их подружить. На тот момент было выбрано просто решение: создать условный заголовок файла с мета-информацией о формате данных, которые хранятся в файле. Это создает что-то вроде контракта между разными самостоятельными сущностями, при этом при соблюдении контракта можно менять формат данных для Writer, не затрагивая Reader.
3. **Зависимость зависимости.** С последствиями такого вида зависимости столкнулись на прошедшей недели. В множество мест предоставлялся доступ к локальному хранилищу и в нескольких местах происходила перезапись токена авторизации. В результате проявлялась ошибка, когда токен оказывался невалидным. В качестве решения будет сделано 2 типа локального стораджа: только для чтения и для записи. Будет сделано централизованное место записи нового токена. Баг следствие плохого проектирования, сознательно такая ошибка будет исправлена.
4. **Зависимость краша.** 
Представим, что у нас есть два экрана в приложении Android: FragmentA и FragmentB. Оба фрагмента независимы друг от друга, но используют общую библиотеку для работы с фильтрами для изображений.
Общая библиотека содержит утилитный класс ImageProcessor, который используется для масштабирования изображений. 
FragmentA и FragmentB используют этот класс для размера превью изображений. В определенный момент времени, обновление библиотеки изменяет поведение ImageProcessor, например, добавляется новый алгоритм масштабирования.
FragmentA и FragmentB могут использовать метод ImageProcessor так:
```
// В FragmentA
ImageProcessor.scaleImage(imageView, imageUrl)
// В FragmentB
ImageProcessor.scaleImage(imageView, imageUrl)
```
Если разработчики FragmentA обновили библиотеку, ожидая новый алгоритм масштабирования, они возможно протестируют свой код и проверят, что всё в порядке. 
Однако, если FragmentB не был надлежащим образом информирован об этом изменении и не был протестирован с обновленной версией библиотеки, приложение может столкнуться с проблемами, так как FragmentB может ожидать, что ImageProcessor работает иначе.
Проблемы могут включать неправильное отображение изображений, сбои во время выполнения, утечки памяти - если изменения в библиотеке влияют на жизненный цикл объектов. Шагов по решению конкретно этой зависимости нет, однако общий подход в больших компаниях - минимизация сторонник решений в пользу самописных. Можно считать это осознанным подходом для уменьшения транзитивных связей в контексте сборки артефактов приложения.
5. **Зависимость пробрасывания.** В таком виде зависимости можно сказать, что А не зависит от В до того момента, как В работает корректно. На прошлом месте работы был мобильный прокси-бекенд, который принимал запрос от клиента и проксировал запрос к одному из внутренних бекендов, и если тот отвечал ошибкой - отдавал подготовленную на такой случай страницу в качестве ответа.
Такая зависимость создана намеренно для повышения отказоустойчивости сервиса, как-то разрешать такую ситуацию намеренно не планировалось
6. **Зависимость инверсии.** Популярный подход так называемой Clean Architecture в Android проектах. Конечно, потребитель А будет от компонента В, как бы В не подавалось на вход компоненту А. DI в данном случае помогает не зависеть лишь от реализации, что упрощает процесс тестирования, особенно интеграционное тестирование. 
Вдобавок, внесение изменения или рефакторинг занимает меньше времени.
7. **Зависимость зацикливания.** Опустившись на уровень кода, зависимости компонента от самого себя может быть примером рекурсивного кода. Если это не просто обход дерева, а что-то более сложное, с изменением частей системы внутри рекурсивного вызова, то такая зависимость может быть и в рамках архитектуры части системы.
Касаясь циклической зависимости, в конце прошлого года наш фреймворк навигации в приложении мог приводить к циклическим зависимостям в краевых сценариях, когда была логика с вызовом навигационного флоу в модуле, отличного от текущего (А -> В) и вдобавок, была логика с возвратом результата в исходный модуль, но с вызовом специфичного экрана (В -> А). 
Проблема понятная, осознанное решение - написание собственного фреймворка навигации с учетом текущих проблем. Более механическое решение в выделение отдельного, промежуточного модуля, ответственного за сцепку двух других.

8. **Зависимость высшего порядка.** Библиотеки не зависят (не должны зависеть) от окружения, в котором они выполняются. (Окружением назван участок кода). 
Однако, в программирование многое можно упростить до схемы: Входные данные - обработка и вычисления - выходные данные. Любой код в какой-то мере зависит от входных данных, особенно "алгоритмический". Ведь даже если алгоритм работает корректно на всех каком-то наборе данных, который мы считаем полным, он вероятно работает с разной скорость, в зависимости того, насколько входные данные "хорошие".
Я всегда задумываюсь о том, какие данные подаю на вход алгоритмам, даже из стандартной библиотеки. Как минимум, можно засунуть изменяемый тип данных в качестве ключа, по ссылке получить этот объект и изменить в нем какой-либо атрибут. К таким особенностям всегда подхожу осознанно.
9. **Зависимость большинства**. Если расценить вопрос с точки зрения вычислительной философии, хотя каждая программа технически идеально соответствует спецификации, фактически каждая программа это по-сути продукт разработчиков, а значит результат толкования и оценки спецификации. 
На основе своего опыта могу сказать, что разработчики пишут программы, который сильно коррелируют не только с их профессиональным опытом, но и другими, не связанными с программированием, факторами. Например, жизненный опыт, ценности, восприятие и т.д. Что касается непосредственно зависимости.
В любом случае, надежность программ нельзя сводить к количественному накоплению различных реализаций, но когда качество работы всей системы зависит от ее подсистем, то сбой даже одной из них должен рассматриваться тщательным образом. Значит, есть связь между всеми вариациями программ.


Выводы:

Ранее, до этого задания, не рассматривал зависимости в зависимости от их типа, вариаций. Многие зависимости ранее рассматривались как ошибки в программе. Но расценивая теперь некоторые из них, как проблемы зависимости, мы делаем такие проблемы разрешаемыми, с которыми уже можем работать в нашей системе и которые можем пытаться устранять.

Следующий важный момент по теме, который нужно отметить, это терминология. Делая задание, приходилось не раз останавливаться для раздумий о том, что же зависимость есть, как ее описать.
Можно было бы рассматривать зависимость как свойство системы, в которой состояние или результат вычисления влияет на работу другого компонента, но все-же требуется больше вводных данных, зачастую эти связи неочевидны или ведут окольными путями. Поэтому такая характеристика ровным счетом не важна, когда, например, приступаешь к рефакторингу запутанной части системы.

Также по поводу зависимостей легко заблуждаться. Возьмем пример, клиентское приложение дергает API бекенда, получает Json, с которым тут же как-то работает. Предположим, что и взаимодействие с бекендом, и обработка находятся в одном модуле.
Охарактеризуем эту ситуация так, что клиент наш зависит от бекенда. Желая устранить такую зависимость, мы заводим слои абстракции, теперь у нас бекенд скрыт за абстракцией "Источник". Источник может быть любой: файл, сокет, http запрос и т.д.
Считаем, что "Источник" настроен на данный момент только один - бекенд, общение через http запросы. Если этот источник отвалился, то клиент наш тоже упадет. 
В итоге, зависимость не ушла, хотя добавили гибкость, настроили клиент на работу с другими источниками. Формат данных опустим.

Или, допустим, мы можем удаленно, с помощью remote config, выбирать Источник на клиентах. Теперь бекенд отвалится, мы смогли поменять Источник, клиент теперь работает с данными через веб-сокет, например.
Но, как оказалось, клиент (мобильное приложение) стал нагреваться, расходовать сильно запас батареи, сокет стал нагружать сильнее бекенд, из-за чего стали чаще выходить из строя сервера, расходы увеличились.
Принимая во внимания эти данные, что мы можем заключить. Что результат "отказа от зависимости" на самом деле не означает, что зависимость между зависимыми компонентами оборвалась. В нашем примере мы, вероятно, сделали нашу систему, включающую все клиент-серверное взаимодействие, более надежным. 
Но тот факт, что мы скрыли зависимость от бекенда за слоем абстракции, не говорит о том, что теперь клиент не зависит от бекенда.
