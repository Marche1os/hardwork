### Поиск акций заведений бизнеса

**Пункт 1. Модульное понимание**

Структура файлов и пакетов была выполнена в монолитном стиле, что мешало понимать программу в схеме независимых модулей.

**Пункт 2**

В коде часто виднелась мешанина бизнес-логики и деталей реализации, например, специфичного UI элемента.
Это сбивало при чтении и приходилось фильтровать важное и несущественное, так как абстракции нелегко было вывести из кода.

**Пункт 3**

Из-за большого количества различных утилитных классов-синглтонов, к которым происходило обращение из различных мест в коде,
такой замысел тяжело улавливался. А зачастую изменения требовали редактирования большого количества файлов. 

**Пункт 4**

Код зачастую был ненадежен и требовал правок сразу в нескольких местах при изменении или исправлении ошибок.

### Приложение по управлению умным домом

**Пункт 1**

Проект является многомодульным с разделением на интерфейсы и реализацию (подход api/impl). 
Это позволяет понимать программу модульно, видеть независимые сущности и их взаимосвязи.

**Пункт 2**

К сожалению стоит констатировать, что нередко такая мешанина, характерная инди-проекту случается и здесь.
Но тут уже проблема не в отсутствии знаний, а в достаточно большой команде, поэтому добиться от всех качества кода сложнее.

**Пункт 3**

Благодаря выработанным практикам документирования, правилам по оформлению модулей - зачастую, удается строить понятный дизайн в коде.
Но в основном это работает с некоторыми типичными фичами. Сложные, требующие глубокой технической проработки фичи редко удается делать понятными.
Зачастую это сопровождается обравочными поясняющими комментариями, за которыми видно пояснение операции, но дизайн за этим не просматривается.

**Пункт 4**

В целом код надежен и устойчив. Например, если требуется переверстать picker выбора даты - затронется только этот UI элемент.
Однако есть legacy, где, например, добавление тени элементу topbar при скролле потребует доработки нескольких мест, включая изменения контракта.

### Заключение

В этом продолжении занятия я продолжил сравнивать проекты, кардинально различающиеся. Один многомодульный, другой монолитный.
И если Google, говоря о преимуществах многомодульности, говорит общими терминами, особо непонятно которые как влияют. 
То имея непосредственный опыт уже реально оцениваешь плюсы и минусы.

Стало очевидно, насколько важно организовывать проектирование системы правильно с самого начала. 
Монолитная архитектура затрудняет понимание и масштабирование, приводит проблемам с ответственностью компонентов. Модульность, разделяющая интерфейсы и реализации, существенно упрощает как сопровождение продукта, так и обучение новых участников команды.

Отдельно по пунктам:
- Грамотное разделение на модули и явные контракты между ними делают проект живучим, удобным для командного развития и масштабирования.
- Документация и стандарты по оформлению кода не менее важны, чем инженерные решения.
- Поддержка легаси систем это всегда сложный и часто болезненный процесс; чем чище архитектура проекта, тем легче проводить подобные изменения. Поэтому важно создавать задачи на техдолг по устранению легаси кода и заниматься этим техдолгом.