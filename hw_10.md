**2.1. Нарушение SRP**
Возьмем класс Context из Android. В Android Context является базовым классом для доступа к ресурсам и сервисам системы Android на уровне приложения, таким как вызов системных служб, доступ к базе данных, файлам, доступ к ресурсам и т.д. 

 Пример:

 ```
abstract class Context {
    abstract fun startActivity(intent: Intent)
    abstract fun bindService(service: Intent, conn: ServiceConnection, flags: Int): Boolean
    abstract fun unregisterReceiver(receiver: BroadcastReceiver)
    abstract fun sendBroadcast(intent: Intent)
    abstract fun getContentResolver(): ContentResolver
    abstract fun getResources(): Resources
    abstract fun getPackageManager(): PackageManager
    // ...
}
```

Большое количество различных функций и методов есть признак величины и сложности класса Context. Это также указывает на нарушение принципа единственной ответственности (SRP), поскольку класс Context управляет многими разными аспектами системы Android, например работой с ресурсами, службами, содержимым, трансляцией и т.д.

Одной из проблем дизайна класса Context является его "всеобъемлющая" роль в Android - он предоставляет слишком много функций, что делает его сложным для понимания и поддержки. Помимо этого, так как Context имеет доступ ко всему и вся, это может привести к утечкам памяти, если он будет использован неправильно. Например, долгоживущие объекты держащие ссылку на Activity через Context могут запретить сборку мусора Activity, после того как она становится неактивной, что приводит к утечке памяти.

В общем случае, большие классы, подобные Context, следует разделять на более мелкие классы, каждый из которых имеет свою конкретную ответственность.

Также, когда создается много инстансов подобных "тяжелых" классов, это негативно будет влиять на производительность программы: здесь и дольше аллокация, и увеличение потребления памяти, что влечет учащенную работу сборщика мусора (если язык поддерживает атоматическую сборку мусора). Также, может быть проблема в том, что каждый класс содержит состояние, чем больше инстансов - тем больше состояний в программе, тем сложнее поддерживать такую программу.


**2.2.**

 Случается, когда есть некий утильный класс для конкретной задачи. Например, класс Mapper, у которого только метод map.
 Другие частые примеры, когда такое случается:
 - Printer с одним методом printSomething
 - ImageBlurer, с одним методом blur.
В принципе, часто можно встроить поведение таких классов с методом непосредственно в код вызова.
 

**2.3.**

class DataManager {
  fun fetchUserData(listener: OnDataFetchedListener) {
    // получение данных пользователя по сети
  }
}

class UserProfileFragment : Fragment() {
  private val dataManager = DataManager()
  
  fun requestData() {
    dataManager.fetchUserData(object : OnDataFetchedListener {
      override fun onDataFetched(data: UserData) {
        // обработка полученных данных пользователя
      }
    })
  }
}


В данном случае метод fetchUserData() в классе DataManager извлекает данные пользователя по сети. Однако, этот функционал является более подходящим для другого класса, такого как UserRepository или UserApiService, который отвечает за взаимодействие с сервером для получения информации о пользователях. По-сути здесь нарушение архитектурных принципов.


**2.4.**

Пример:
class FeatureConfigManager {
    private val configData: MutableMap<String, String> = mutableMapOf()

    fun setConfigValue(key: String, value: String) {
        configData[key] = value
    }

    fun getConfigValue(key: String): String? {
        return configData[key]
    }
}

Класс FeatureConfigManager хранит конфигурационные данные, которые загоняются в него из разных мест в программе. Такой подход усложняет определение изменений в конфигурации, а также следование принципу единственной ответственности, так как класс отвечает за хранение и доступ к конфигурации.

Можно рассмотреть перенос хранения и доступа к конфигурации в отдельный класс, такой как ConfigRepository, который будет обеспечивать централизованное управление конфигурацией.


**2.5.**

Пример:
class OrderProcessor(private val db: SQLite) {
    fun processOrder(order: Order) {
        // Обработка заказа с использованием SQLite
    }
}

Класс OrderProcessor принимает зависимость на конкретную реализацию базы данных SQLite. Это делает класс жестко связанным с деталями реализации, что может создать проблемы при изменении базы данных или переходе на другую реализацию.

Можно использовать принцип инверсии зависимостей и внедрить зависимость через интерфейс или абстракцию базы данных, чтобы класс OrderProcessor зависел только от абстракции, а не от конкретной реализации БД.


**2.6.**

Пример:
open class Vehicle { }
class Car : Vehicle() { }
class Truck : Vehicle() { }

fun main() {
    val vehicle: Vehicle = Car()
    (vehicle as Car).drive()
}

Приведение типов вниз по иерархии может привести к ошибкам времени выполнения, если фактический тип объекта отличается от ожидаемого типа после приведения.

Вместо приведения типов можно использовать полиморфизм и механизм динамического вызова методов, чтобы избежать ненужного приведения типов и обеспечить правильное выполнение соответствующих методов для каждого типа объекта.

**2.7.**

abstract class BaseAdapter : RecyclerView.Adapter<RecyclerView.ViewHolder>()

class EventAdapter : BaseAdapter() {
  //...
}

class PostAdapter : BaseAdapter() {
  //...
}


В этом примере класс BaseAdapter является абстрактным базовым классом для различных адаптеров в RecyclerView. Когда разработчик создает класс-наследник, например, EventAdapter или PostAdapter, он также должен создать новый класс-наследник для каждого нового типа адаптера. Это может быть признаком плохого проектирования, особенно если логика адаптеров очень похожа, как часто бывает.

**2.8.**

open class BaseActivity : AppCompatActivity() {

    protected open fun setupToolbar() {
        // Здесь код для настройки панели инструментов (toolbar), который должен быть общим для всех активностей
    }

    protected open fun displayMessage(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
        // Метод для показа toast сообщения пользователю
    }
}


Допустим также, у нас есть подкласс MainActivity, который наследуется от BaseActivity.

class MainActivity : BaseActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Разработчик забыл вызвать метод setupToolbar(),
        // поэтому общий код настройки панели инструментов не будет выполнен для MainActivity

        // Разработчик переопределяет метод displayMessage(), 
        // но не использует родительский метод, дублируя код
    }

    override fun displayMessage(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
    }
}


В этом примере идея переиспользования кода, лежащая в основе наследования, не реализуется полностью, так как разработчик забыл вызвать setupToolbar, а функция displayMessage переопределена без вызова родительского метода, что привело к дублированию кода. Этого можно было избежать, если бы оба метода были правильно использованы в дочернем классе.

**3.1**

Эта проблема возникает, когда изменение в одной части кода приводит к необходимости внесения изменений в несколько классов, из-за сильных зависимостей и связанности между ними. 

Примером может быть ситуация, когда разработчик изменяет структуру базы данных, и в результате должен изменить не только модель данных, но и соответствующие классы для доступа к базе данных, а также классы для работы с данными в пользовательском интерфейсе. Здесь база данных упомянута в качестве примера, на практике Android разработчики работают чаще с данными с сервера. 

class User {
    // поля и методы модели
}

class UserRepository {
    // методы для работы с базой данных, использующие модель User
}

class UserViewModel {
    // методы для работы с пользовательским интерфейсом, использующие модель User
}


Если требуется изменить структуру модели User, это может привести к необходимости изменения в классах UserRepository и UserViewModel. В результате, изменение одного аспекта может затронуть несколько классов.

Чтобы избежать подобной проблемы, следует стремиться к слабой связанности между классами и использовать принцип инверсии зависимостей и инъекцию зависимостей, чтобы уменьшить зависимости между классами и сделать их более гибкими и легкими для изменения. Также, архитектура проекта делится на слои: data, domain, presentation. И в каждом слое своя модель данных. Например, UserDto, UserDomain, UserUI.


**3.2.**

Примером может служить использование паттерна "Абстрактная фабрика" для создания объектов различных типов, хотя в данном случае простое условное ветвление могло бы быть более простой и менее сложной реализацией.

interface Animal {
    fun makeSound()
}

class Dog : Animal {
    override fun makeSound() {
        println("Woof!")
    }
}

class Cat : Animal {
    override fun makeSound() {
        println("Meow!")
    }
}

// Использование паттерна Абстрактная фабрика
interface AnimalFactory {
    fun createAnimal(): Animal
}

class DogFactory : AnimalFactory {
    override fun createAnimal(): Animal {
        return Dog()
    }
}

class CatFactory : AnimalFactory {
    override fun createAnimal(): Animal {
        return Cat()
    }
}

// Использование паттерна
val factory: AnimalFactory = DogFactory()
val animal = factory.createAnimal()
animal.makeSound()


В данном случае использование паттерна "Абстрактная фабрика" может быть избыточным, поскольку простое условное ветвление, например с использованием when-выражения, может быть проще и понятнее:

fun createAnimal(type: String): Animal {
    return when (type) {
        "dog" -> Dog()
        "cat" -> Cat()
        else -> throw IllegalArgumentException("Invalid animal type")
    }
}

val animal = createAnimal("dog")
animal.makeSound()


Сложные паттерны проектирования должны быть использованы тогда, когда они действительно решают конкретную проблему или обеспечивают нужную гибкость и расширяемость. В противном случае, их использование может усложнить код и сделать его сложнее для понимания и поддержки.


**Выводы**

Разобрав проблемы из текущего занятия, немедленно вспоминается книга Ван Тассела "Стиль, разработка, эффективность, отладка и испытание программ". Проблемы, разобранные в этом задании, все связаны с проблемами, допущенными при проектировании классов. И рекомендации, данные в первых даже главах, позволили бы сильно улучшить проектирование и минимизировать или вовсе уйти от ошибок проектирования. Стремиться к простоте, проектировать сперва на естественном языке, на псевдокоде, рисовать блок-схемы - очень сильно улучшают качество спроектированной системы. Даже на своем опыте, когда подхожу к задаче, требующей проектирования некоторого компонента или системы, сперва проектирую на листочке. Так ты можешь позволить себе погрузиться полностью в решаемую задачу, полностью погрузиться в саму задачу и требования. Ранее на курсе были задания на тестирования, на подходы к тестированию. Почему, например, подход "Сперва тесты, потом реализация" в целом позволяют на выходе получать более надежный код с меньшим количеством проблем? Потому что когда пишешь тесты, разработчик думает на уровне данных: входных, выходных. И мозг сам подкидывает новые идеи, специфичные для среды, в которую погружен в момент времени. А сходу писать production-ready код, без проектирования, тестов - губительно, ведь ты не погружен в задачу, а значит сходу упускаешь многие детали. 
В общем, что можно вынести:
- проектируйте на листочке;
- блок-схемы и псевдокод должны встречаться не только в университетах и научных работах, но и в повседневной практике;
- документируйте разрабатываемые системы до начала программирования. 