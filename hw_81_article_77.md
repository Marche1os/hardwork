

1. Архитектурная секция. Когда просят построить архитектуру приложения, например, мессенджера, и ожидают типичный подход "порисовать квадратики, правильно обозвать сущности в них и стрелками соединить". И к такой архитектуре предъяаляются требования надёжности и масштабируемости. Я критикую, что такая дизайн-схема части системы называется архитектурой и каким-то образом она может быть надёжной. Я бы отметил, что надёжность - это создание выразительного, простого кода, в котором исключены целые классы ошибок (используя, например, строгую систему типов) и в котором очевидна связь с другими компонентами системы. А также понятно, как та или иная сущность соотносится к предметной области.

2. Когда просят рассказать отличие Sequence от обычных списков. Я как-то проходил собеседование в VK, меня спрашивали отличия sequence от других коллекций. Я рассказывал о sequence с инженерной точки зрения: что это концепция бесконечных списков, позаимственная из функциональных языков. Что мы можем вычислять значение последовательности только в момент необходимости, а не сразу. Но интервьюер настойчиво не принимал ответ. Я настаивал на своей позиции, наконец, он ответил, что отличие можно представить так: последовательности это вертикальная структура данных, а коллекции - горизонтальная. Что цепочки операций над последовательностями не создают промежуточных состояний. А это типичный вариант ответа, который много где приводится, включая канал Гладкова.

3. Когда говорят о RxJava как о инструменте для асинхронного выполнения кода. Всегда раздражало, когда интервьюер говорит о реактивном программировании исключительно в контексте асинхронщины. RxJava вообще не об этом! Rx привносит целую философию в язык, опираясь на принцип функционального программирования: ссылочная прозрачность, иммутабельность и функции типа map, flat, reduce. И ключевое, это модель "источник данных-подписчик". А возможность менять потоки выполнения и выполнять какие-то цепочки операций на других потоках это всего лишь side effect.

4. Про стандартные методы equals и hashcode. Слышал, что некоторые интервьюеры просят оценить оптимальность реализации стандартных методов equals и hashcode и написать свою, более эффективную реализацию. Эти умники не учитывают, что jvm оптимизирует эти методы настолько, что делает бесполезным написание более эффективной реализации. Я бы сослался на доклад Шипилева, который высмеивал таких оптимизатор, которые тупо посмотрели исходники стандартных методов и побежали писать свои, более "эффективные" реализации.
Примеры оптимизаций:

Escape analysis

JVM может:

- устранять вызовы equals,
- устранять вызовы hashCode,
- устранять сами объекты.

В результате в hot‑path вызовов может вообще не остаться.

Виртуальный dispatch collapsing

Если тип объекта определён статически, JVM может убрать виртуальность вызова, превратив equals() в прямой вызов заранее известной реализации.

### Выводы

Нашёл для себя полезность такого "умничания" в том, что можно использовать заведомо неуспешное с точки зрения прохождения собеседование превратить в полезный инженерный спор, при условии, что интервьюер действительно разбирается в том, о чем спрашивает (хотя вряд ли). 

По моему опыту таких интервьюеров, которые намеренно сливали, не было. Но были такие, которые не принимали ответ, так как ожидали "типичной" формулировки ответа, как в моем случае при собеседовании в VK. К таким отношение не лучше, ибо они не видят глубины собственного вопроса и весьма ограничены в понимании вопроса.

 