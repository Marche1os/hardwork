### 1. Задание 1. Примеры логики с одинаковой реализацией, но разной спецификацией 

### Пример 1. Обработка ошибок подключения устройств
   - Обработка ошибок типа Wi-Fi
   - Обработка ошибок типа MQTT

Спецификация для примера 1, для обоих тикетов:
- Условие: ошибка возникает, когда библиотека *cast уведомляет об ошибке
- Показ сообщения об ошибке в виде отдельного экрана
- Гарантировать корректную отписку от активного соединения

### Пример 2. Загрузить данные, закешировать на устройстве и отобразить
- Загрузить список устройств
- Загрузить главную

**Спецификация для примера 2:**

Тикет 1. Проверить кэш. Загрузить данные, если кэш пуст или протух, добавить в кэш и отобразить на экране. 
Или вернуть сразу сохраненные данные

Тикет 2. Проверить наличие интернет-соединения, если сети нет - проверить кэш. Иначе загрузить данные и отобразить.
Обработку сетевых ошибок выполнить, как везде на проекте.

#### Пример 3: Сообщения и уведомления
- Тикет 1. "Пуш-уведомления для маркетинговых кампаний" - должны иметь простой текст и быть легко отключаемыми пользователем.
- Тикет 2. "Уведомление о новой версии приложения" - должны отображаться с высоким приоритетом и не выключаться до действия пользователя.
- Тикет 3. "Сообщения о новом контенте в приложении" - напоминающие уведомления с превью и возможностью быстрого просмотра нового контента.


### 2. Задание 2. Универсальные обобщённые полиморфные функции и боксинг

В целом в боксинг не скатывался, но отлично помню те времена с первой работы, где я был единственным разработчиком.
В то время действительно часто прием "рефакторинга" - это просто увидеть дублирующий или даже похожий код, 
упаковать в одну функцию, добавить ей параметров, чтобы можно было управлять блоками кода для исполнения и посчитать это выполненной оптимизацией.

Или вот типичный случай из Android разработки - сверстал несколько различных экранов и увидел, что какие-то UI элементы похожи. 
И пытаться сделать единый экран с точечной настройкой отображения, чтобы подходило под требования конкретного экрана. 
И проблема больше в том, что это делается только на уровне команды разработки. 
Более правильно нужно создавать дизайн-систему и заставлять дизайнеров работать с компонентами из этой системы.
Тогда будут действительно общие компоненты.


### 3. Задание 3

Вообще ответ зависит, конечно, от модуля, в котором приходится работать. Есть сложные модули (в плане метрик сложности кода),
а есть те, которые разрабатывали мы с близкой коллегой. Но для примера, при добавлении продуктовых метрик в сценарий подключения устройств,
я бы оценил такое количество в пару десятков раз. Одна из проблем - отсутствие доменной системы типов, что мешает погрузиться в 
предметную область фичи. Другой фактор, это программирование логики на уровне операторов, если можно так выразиться.
Следствием этого является думание о функции/классе на том же самом уровне, если только ты не автор этого кода.

Вариантов для минимизации, как было видно из пародийного примера, может стать соблюдение баланса при использовании абстракций.
Многослойные абстракции ведут к "прыганиям" между файлами, размазыванию логики, которая является самостоятельной единицей, между файлами/классами.

Также для минимизации таких обращений абсолютно обязательно документирование модулей, классов как компонент, функций.


**Выводы**

Часто приходится сталкиваться с боксингом в проекте, то и дело, что кто-то возьмет и отрефакторит код, объединив в единую функцию или класс какие-то
похожие реализации различных между собой спецификаций. Жаль, что пока в проекте у людей нет привычки описывать спецификацию функций/классов,
JavaDoc часто пишется "чтобы был" и в реальности не несет пользы: не описывается спецификация, не описана связь с другими сущностями и т.п.

У меня готовится доклад на тему документирования и очень рассчитываю, что по итогам сможем создавать правильное документирование и проблема антипаттерна "боксинг" будет нивелирована за счет того, что у нас явно будет описываться спецификация в коде.

Хочу также сказать, что рад найти подтверждение своей мысли о многослойных абстракциях, о том какая это бесполезная вещь.

Большее понимание конкретных вещей, которые часто включаются в термин "абстракция", как мне видится, позволит
осмысленно разделять эти вещи между собой и соответственным образом с ней работать. 

Что еще я лучше усвоил, это правило сравнения кода. Так, дублирующий код с одной спецификацией не равен такому же коду, но с другой спецификацией.
На самом деле примеры, почему это правило такое, были и раньше, но их не удавалось увидеть и понять. Не было знаний по спецификации.
На одном из проектов была унифицирована логика с обработкой ответа с сервера, когда он явно присылал в ответе ошибку с описанием.
Ранее считалось, что ошибка - это точно ошибка и должна отправиться метрика сетевой ошибки. Но ошибки могли быть и "доменные", например, когда достигнут порог по количеству
товаров в корзине, то нам приходит ошибка, что больше товаров нельзя добавить. Но из-за унифицированного подхода, штатная ситуация воспринималась как серьезная ошибка добавления в корзину, что приводило нередко к созданию инцидентов.

В заключение отмечу, что материал интересный, я произучал его два раза и буду изучать еще. 
Кажется, что в программировании часто используют различные термины, которые часто используются, но не все люди использующие термин подразумевают одно и то же.
Например, меня абсолютно раздражает, когда говорят про контракты с бекендом и при этом не валидируют данные на бекенде, ссылаясь на контракт.
Такое неправильное понимание и использование термина вообще-то ведет к реальным ошибкам, исключительным ситуациям и порой к потере денег.

Поэтому важно понимать термины правильно, по крайней мере учитывать возможные различия в трактовке. Теперь и за термин Абстракция возьмемся. 