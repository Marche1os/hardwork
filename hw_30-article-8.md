### 1.

```kotlin
// Функция генерирующая бесконечную последовательность чисел Фибоначчи
fun fibonacciSequence() = sequence {
        var terms = Pair(0, 1)

        // бесконечный цикл. 
        // структура выходной последовательности напрямую определила структуру кода: последовательное генерирование каждого следующего числа фибоначи.
        while (true) {
        yield(terms.first)
        terms = Pair(terms.second, terms.first + terms.second)
    }
}
```

### 2.

```kotlin
/**
 * Генерация объекта данных исходя из входных параметров
 */
fun createScenarioState(
        widgets: List<Widget>?,
        templates: List<ScenarioTemplate>?,
    ): ScenarioState {
    /**
     * оцениваем каждый каждый параметр, что создать необходимый объект данных.
     * Возвращаем ошибку, когда свойство [widgets] равно Null
     * Объект данных пуст (None), когда обе структуры данных не содержат значений
     * Иначе создаем объект данных [Widgets] | [Templates] для соответствующей структуры
     */
    return when {
        widgets == null -> Error
        widgets.isNotNullOrEmpty() -> Widgets(widgets)
        widgets.isEmpty() && templates.isNullOrEmpty() -> None
        templates.isNotNullOrEmpty() -> Templates(templates)
        else -> throw IllegalStateException()
        }
    }
```

### 3.

```kotlin
data class TreeNode(val value: Int, val children: List<TreeNode>)

// Функция generateTree поддерживает ко-рекурсивный подход,
// следуя за структурой создаваемых данных (дерево).
fun generateTree(nodeValue: Int, depth: Int): TreeNode {
    // Базовый случай ко-рекурсии: возвращает узел без детей, останавливает дальнейшую рекурсию.
    if (depth == 0) return TreeNode(value = nodeValue, children = listOf())

    // Рекурсивно генерирует двух детей, применяя корекурсивный подход.
    val children = List(2) { index -> generateTree(nodeValue * 2 + index, depth - 1) }
    
    // Возвращает узел дерева с заданным значением и списком детей.
    return TreeNode(value = nodeValue, children = children)
}
```

**Выводы**

Для начала скажу, что было непросто "прочувствовать", полностью осознать и применять методику, даже по истечению задания не уверен в полной ясности.
Ясно то, что когда дело касается рекурсии, то большинство разработчиков, работающих в типичных мейнстримных проектах и технологиях, впадают в ступор и их мозг ломается.
Но спустя пару дней непрерывного погружения в эту тему, ощущаешь как мозг становится мощнее и ты полностью проникаешься в рекурсивные вызовы и можешь в голове представить стек вызовов функции и раскрутить его до нужных параметров входных данных.

Дополнительно кажется, что корекурсивный подход позволяет удерживать высокую производительность, 
так как элементы структуры генерируются по мере необходимости, и не требуется занимать память для хранения всех элементов сразу. 
Это делает корекурсию особенно привлекательной для работы с большими или бесконечными данными, а также может позволить применить хвостовую рекурсию.

Хочу так же отметить, что проникся идеей "игры в вопрос", очень хорошо позволяет создать правильную структуру мышления при проектировании чего-либо, буду стараться использовать в повседневной работе.
И плюс такие вопросы помогают в принципе понимать лучше рекурсивные вызовы.

Бегло пролистал htdp.org, планирую застрять на этом сайте подольше и найти другие важные для развития вещи.
