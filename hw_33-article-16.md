### 1 Мемоизация

```kotlin
class Memoize<in I, out O>(val f: (I) -> O): (I) -> O {
    private val values = mutableMapOf<I, O>()

    override fun invoke(x: I): O {
        return values.computeIfAbsent(x) { f(x) }
    }
}

fun <T, R> ((T) -> R).memoize(): (T) -> R = Memoize(this)
```

Пример реализации мемоизации. Во-первых, мы предоставляем функцию `memoize`, которая может быть вызвана на любой функции,
имеющей один входной параметир и один выходной параметр.
Сферы использования функции могут быть разными, например:
- Сохранить результат вычисления "чистой" функции, чтобы при повторном вызове с тем же параметром сразу, без вычислений, вернуть результат;
- Свойство мемоизации я использовал, когда необходимо было отправить событие аналитики для конкретного дома раз в сессию. Если дом изменился, то отправляется событие, при этом обновление экрана того же дома не ведет к отправке аналитики. 

Код для второго примера:
```kotlin
val runOnceForHome = { homeId: String -> sendHomeShownAnalytic(homeId) }.memoize()
```

### 2 Подключение (пейринг) умных устройств

Абстракция представляет собой фичу "Подключение умных устройств". 
Почему эта абстракция хорошая? Потому что все сложности с сопряжением, сложности аппаратного уровня, все скрывается
за простой высокоуровневой функцией "Подключить". Кроме того, хотя фича подключения и относится к нашему проекту,
однако эта абстракция не привязана именно к нашему проекту и может использоваться в других проектах, имеющих подключение устройств.


```kotlin
// Абстракция устройства, по которому требуется подключение
interface ConnectableDevice {
    val name: String
    val connection: DeviceConnection

    // Метод для инициализации процесса подключения
    fun initiateConnection(): Boolean {
        println("Initiating connection for $name")
        return connection.connect()
    }
}

// Абстракция подключения устройства через bluetooth. 
class BluetoothDevice(override val name: String) : ConnectableDevice {
    override val connection: DeviceConnection = BluetoothConnection()
}

// Абстракция подключения устройства через Wi-Fi
class WiFiDevice(override val name: String) : ConnectableDevice {
    override val connection: DeviceConnection = WiFiConnection()
}
```

### 3 Поток выполнения

Хотел бы упомянуть такую абстракцию, как Поток выполнения. Мы по-разному используем потоки, спектр задач, когда это полезно, достаточно широк.
Но в основном это касается вопросов ускорения программы, участка кода. 
При этом создание потоков не всегда связано именно с параллелизмом, и на одноядерных процессорах можно создавать десятки потоков выполнения.
Дело в том, что мы хотим создать еще одну нить выполнения кода. 
При этом детали планировщика потоков остаются на стороне окружения, в котором работает программа или приложение.
Если говорить в контексте JVM, то мы имеем множество операций, как АТД, над потоком. 
Основные это команды запуска, создания, остановки и приостановки потока.

```kotlin
import kotlin.concurrent.thread

val thread = thread { 
    // операции из новой нити выполнения
}.start()
```

 ### 4 Управление умными устройствами
Пример выдуманный, но хочется показать абстракцию. Представим некоторый уровень [Level], 
который вносит категории: LOW, MIDDLE, HIGH. Это может быть абстракцией для множества сущностей.
Например, для уровня яркости и громкости.  
Этот интерфейс можно воспринимать как шаблон для контроля над различными устройствами или аспектами системы (контроллер управления)
Интерфейс `Controller` и его реализация позволяют подняться на новый уровень абстракции, где управление уровнями (громкости или яркости) рассматривается просто как изменение состояния, не вдаваясь в детали реализации. Это дает возможность рассуждать более абстрактно и точно.

```kotlin
enum class Level {
    LOW,
    MIDDLE,
    HIGH,
}

interface Controller {
    fun changeTo(newLevel: Level)
}

class SoundController : Controller {
    override fun changeTo(newLevel: Level) {
        // меняем уровень громкости    
    }
}

class LightController : Controller {
    override fun changeTo(newLevel: Level) {
        // меняем уровень яркости 
    }
}
```

### 5 Архитектура MVI

MVI позволяет разработчикам думать о приложении в терминах состояний и событий, что упрощает понимание и предсказуемость поведения системы,
ускоряет адаптацию новых разработчиков на проекте за счет предсказуемости архитектуры.
Это тот самый семантический уровень, который позволяет рассуждать в терминах состояний компонентов системы (как правило, это фича, какой-то экран с бизнес-логикой)
в терминах архитектуры MVI, понимать связи между подкомпонентами системы.

MVI делит систему на три ключевые компоненты (Model, View, Intent), 
взаимодействие между которыми легко предсказуемо. 
Intent инициирует действия, View отображает состояние, а Model управляет состоянием.


```kotlin

// Абстракция состояний View
sealed class ViewState() {
    object Loading : ViewState()
    data class Content(val data: List<Any>) : ViewState()
    data class Error(val error: Throwable, val readableText: String) : ViewState()
    object NoContent : ViewState()
}

// Абстракция намерения
sealed class ViewIntent {
    object LoadData : ViewIntent()
    data class ShowData(val data: List<String>) : ViewIntent()
    data class ShowError(val error: String) : ViewIntent()
    object ShowNoContent : ViewIntent()
}
```


### Определение Дейкстры

Мы в повседневной практике повсеместно используем абстракции: 
Упомянутый поток выполнения, который является абстракцией параллелизма (в общем смысле слово), сама JVM, garbage collector (хотя с этим примером все сложней ввиду того, что реализации GC могут сильно различаться, хотя и результат всегда преследуется один).
Однако, почему мы не создаем абстракции, которые позволяют рассуждать о системе, понимать систему в широком смысле слова?
До сих пор мы пишем комплексные фичи (например, управление светом) через примитивные операторы. Другие люди, изучая функциональность, также находятся на уровне операторов.
Можем ли мы, придя на завод и увидев выпуск конкретной детали, узнать, а что вообще создается, частью какой сконструированной вещи будет деталь?
Такой же принцип применяется в большинстве проектов сегодня.

Дейкстра говорит о том, что мы должны выделять из требований самостоятельные функциональные компоненты и создавать из них самостоятельные сущности, в идеале указывая спецификации и документируя их. 
В свою очередь это предоставляет нам возможность видеть эти целые сущности, рассуждать о них, видеть связи с другими сущностями и в этом и заключается точность и новый семантический уровень.

С учетом таких выводов и определений, нужен пересмотр привычного подхода к созданию новых функциональностей. 
Начинаем с выделения самостоятельных функциональных сущностей, которые имеют документацию и спецификацию. 
Созданная таким образом сущность будет являться частью системы остальных сущностей проекта.
А реализация должна выводиться минимальной, удовлетворяющей требованиям спецификации.

### Выводы

В процессе делания задания то и дело вспоминался курс СИКП, точнее одна из приблизительных фраз профессора: "Вы хотите деталей реализации, но я вам их не дам. 
Они вам не нужны, чтобы понимать происходящее. Более того, детали навредят пониманию.".

В последнее время все активнее продвигаю практики и идеи для создания по-настоящему поддерживаемого кода соблюдением правил проектирования по созданию
надежных, гибко развивающихся систем, у которых и сложность растет линейно с ростом кодовой базы, поэтому это задание поможет в достижении моей персональной цели
по созданию выстроенной архитектуры в приложении.  
Более того, еще не завершив задание, я уже поднял тему абстракции на одно из пулл реквестов коллеги. Планирую и по этой теме сделать доклад.

Текущее задание по теме абстракции тесно переплетается с материалом по уровням рассуждения о программе. 
Можно сказать, правильные абстракции служат той же цели: иметь возможность думать о программе на 3-м логическом уровне и не скатываться на уровень кода без необходимости.
Когда достигается такой эффект, перед нами открываются возможности для новых возможностей в программировании:
например, легче будет создавать DSL, так как мы будем видеть сущности и четче понимать объем допустимых над этими сущностями операциями.
Появится также возможность DSL описывать правильнее за счет функций первого порядка, которые расширяют конкретный тип сущности. 
Это особенность языка Котлин, когда можно создавать extension функции - функций, расширяющие тип без необходимости наследоваться от него.
Такая особенность хорошо используется при создании DSL.

И еще один из выводов по заданию, это то, что в мейнстриме многие термины искажены и используются неправильно. Например, "Контракт" понимается неправильно
очень часто и об этом упоминал в одном из отчетов по карьере. Термины паттерны, абстракция - тоже несколько искажены, истина переплетается с ложью,
что ведет к неправильному пониманию, неправильному использованию и как следствие - ошибкам в проектировании. 

Также хочу поделиться впечатлениями от этого задания, потому что оно точно самое запоминающееся на данный момент.
Неоднократное перечитывание материала, рефлексия об абстракциях в процессе блуждания вокруг пруда оказала влияние и приблизило, надеюсь, к истинному пониманию.
Такому пониманию, которое позволило бы не только чувствовать, что "вот-вот понял на уровне одного из отделов мозга, но рассказать не могу", а и в действительности
переложить это понимание на конкретный отчет.
