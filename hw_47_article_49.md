1: Интеграция с устройствами  
Проблема: Приложение должно было поддерживать управление "любым умным устройством" от разных производителей (лампы, термостаты, камеры и т.д.) и работать с любыми протоколами (Wi-Fi, Zigbee, BLE).  
Ограничение: Был разработан интерфейс DeviceAdapter, и каждое новое устройство добавлялось через реализацию этого интерфейса, управляя предопределенными командами (turnOn, turnOff, getStatus). Протоколы абстрагировали через модули (WifiManager, BLEManager).  
Полный отказ: Вместо поддержки "всех" устройств, приложение ограничили только устройствами с интеграцией через стандарты, такие как MQTT или определенные API, требуя от производителей настройки совместимости.

---

2: Сценарий автоматизации
Проблема: Пользователи хотели создавать скрипты, сочетающие автоматизацию любой сложности, например: "Если Камера 1 зафиксировала движение, уменьшить яркость Лампы 2 и отправить уведомление".  
Ограничение: Мы ограничили число поддерживаемых триггеров (MotionDetectedTrigger, TimeBasedTrigger) и действий (TurnOnLightAction, SendNotificationAction), позволяя создавать сценарии в рамках строгого DSL (Domain-Specific Language).  
Полный отказ: В новой версии приложения от сложных сценариев отказались в пользу предварительно настроенных простых профилей ("Охрана дома", "Режим сна"), которые автоматизируют распространенные задачи без детальной кастомизации.

---

3: Архитектура подключения к серверу
Проблема: Требовалось реализовать механизм, способный работать с любым облаком производителей умных устройств (их сервера иногда отличаются по доступным API/данным).  
Ограничение: Архитектура приложения была разделена на три слоя: CloudManager (отвечает за общие задачи подключения), отдельные SDK или адаптеры для каждого облака, и универсальная обработка данных через абстрактный формат (например, DeviceState).  
Полный отказ: Полностью от идеи "подключать любые облака" отказались, сосредоточившись только на поддержке ноутрейшен протоколов Matter и HomeKit, что обеспечило совместимость со стандартными API устройств.

---

4: Интерфейс управления умным домом
Проблема: Требовалось, чтобы интерфейс приложения позволял управлять "любым устройством" и настраивать любое UI представление для пользователей (например, гибкие плитки или кастомные панели управления).  
Ограничение: Ограничили приложение дефолтным подходом с плиточным интерфейсом, где каждая плитка обрабатывала только четко определенные категории устройств, и адаптеры предоставляли данные в определенном формате (например, процент яркости для ламп).  
Полный отказ: Отказались от гибкой настройки UI вообще. Вместо этого пользователям предложен фиксированный дизайн с понятными элементами управления на основе типов устройств.

---

5: Логика работы устройств в оффлайн-режиме  
Проблема: Устройство должно было поддерживать автономную работу любого сценария, даже если сервер недоступен.  
Ограничение: Оптимизация достигнута путем добавления у каждого сценария приоритетности работы в оффлайн-режиме (Critical, Optional). Например, включение сигнализации работало без проблем локально, а менее важные вещи (например статус батареи) синхронизировались только через сервер.  
Полный отказ: Режим оффлайн был поддержан только для базовых сценариев (включение света, открытие дверей), исключая сложные сценарии автоматизации, требующие сервера.

---

▎Выводы

Для большого Android-приложения по управлению умным домом необходимо чётко осознавать границы "всего", чтобы проект не вызывал рост сложности до неконтролируемого уровня. 
Ограничение применяется чаще, чтобы сохранить гибкость, а полный отказ - чтобы упростить разработку, сократить бюджет и ускорить релизы.
С продуктовой точки зрения бизнесу лучше сохранять высокую скорость выпуска фичей, поэтому накладываемые ограничения, если они позволяют сделать больше проектов, бизнес принимает.

Кроме этого есть общее мета-правило: чем труднее принимать ограничения некоего API, тем более вероятно, что использование этого API не может быть в неправильном ключе и тем контролируемее будет его развитие.  