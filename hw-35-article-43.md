### 1 Поддержка рекламного баннера

Визуально баннер представлял собой картинку под размер всего баннера, а также текстовки с кнопкой закрытия баннера.
Звучит просто. Однако картинка может иметь разное цветовое наполнение, соответственно встает вопрос поддержки различимости текстов и иконки закрытия баннера.

Второй момент - это поддержание рекламного баннера в актуальном состоянии, ведь они могут довольно часто меняться. При этом требовалось по возможности показывать баннер максимально быстро и не грузить лишний раз картинку.
Это привело к тому необходимости кеширования баннера на устройстве и загрузке самого изображения баннера, дополнительно требуется в фоне уточнять актуальность баннера и при необходимости изменять его на новый.

В итоге все это вылилось в проверки наличия баннера в кеше, проверки времени жизни баннера, если он есть в кеше, потом в получении баннера с сервера и проверке его с сохраненным на устройстве..

Хочется отметить, что все обработка всех этих краевых случаев - это дополнительный проект по доработкам, который был выдуман лидом разработки, продуктовая ценность этого всего стремится к нулю.
По-хорошему, следовало признать требования по поддержке актуальности баннера - излишними, максимум, что необходимо было сделать - это учесть разные виды изображения, что и было нами сделано в первой итерации проекта.

### 2 Прорастание данных на бекенде с задержкой

Ситуация следующая: уведомляем бекенд о добавлении пользователем нового устройства, бекенд отвечает успехом, но.. устройство может прорастать на бекенде какое-то время.
То есть, добавили устройство, перешли на другой экран, на котором показываем все устройства пользователя, а нового девайса нет. Нужно ждать, обновлять страницу и когда-нибудь оно появится.

По-правильному нужно заставить бекендеров соблюдать требования архитектуры REST, но, конечно, это было дорого там исправлять.
Нам же пришлось выдумывать кеширование, дополнительно завязываться на какие-то события вебсокета, чтобы после подключения устройства оно сразу отображалось.

### 3 Обработка кодов ошибок в сценарии авторизации

Отчасти продолжение предыдущего пункта. Иногда, если устройство еще не проросло, а уже как-то пытаешься с ним взаимодействовать, то бек вернет 403 код ошибки.
Согласно требованиям ТЗ, 403 код ошибки любого endpoint воспринимается как протухание токена авторизации, требуется запустить процесс обновления токена.
Соответственно, требуется обрабатывать уже конкретный endpoint и смотреть ответ оттуда, чтобы понять, требуется запускать процесс рефреша или нет. 
И таких endpoint несколько. Вообще, такая несогласованность сервисов - это большая проблема и одна из первых таких проблем, которые я заметил, когда только пришел в компанию.

Работали с этим случаем "в лоб" - накладывали условные проверки с комментариями, что тут происходит и какой кейс решается.

### 4 Показ экрана ошибки в зависимости от кода ошибки и поля в ответе

Почему-то нельзя обойтись универсальным экраном ошибки, нужно обязательно конкретизировать, что именно пошло не так. Хотя смысла в этом ровно 0, так как пользователь на своей стороне все равно не сможет обойти проблему.
В итоге, на одном из экранов было около 10 различных вариаций кодов ошибки (401, 403, 409, 500) и в ответе поле `error`, которое как-то описывало, что именно пошло не так. 

Возможно, такое разнообразие в чем-то и оправдано, однако скрывает под собой корень проблемы - слабую проработку пользовательского флоу, что он может столкнуться с такой вариацией ошибок.

Чтобы как-то вынести за скобки такую специфичную и немаленькую логику обработки ошибок, были разделены классы между собой, был использован делегат для делегирование обработку и показ ошибки на сторонний компонент.

Если бы я участвовал в проектировании этой фичи, то прделожил бы пересмотреть вообще пользовательский флоу, сделать его "строже", если угодно, с целью убрать такое количество ошибок, на которые можно наткнуться.

### Как обходиться с краевыми случаями

Под конкретный случай стоит подумать над конкретным "рецептом", как можно с этим корнер-кейсом справляться. 
Например, для моего первого примера, кажется, лучше подходит дополнительная абстракция: создание класса, который будет отвечать за предоставление актуального баннера.
Класс может предоставлять интерфейс подписки на баннер, внутри класса - логика по кешированию баннера и его актуализации. Иными словами, клиент подписывается на получение баннера, и каждый раз, когда его требуется обновить - источник данных предоставляет подписчикам новый, актуальный баннер.

Для большого числа случаев стоит обговаривать с менеджерами пограничные случаи. Не всегда оправданно тратить время разарботки на поддержку этих редковозникающих случаев.

Идея с тем, чтобы в коде явно выделять "странные" кейсы - любопытная, как минимум стоит комментариями такое помечать.

### Выводы

К сожалению, нередко встречаются ситуации в коде, где 10-20% - это основная логика, а остальное посвящено различным пограничным сценариям.

Одна из больших проблем, что мне довелось видеть в разных компаниях - это то, что разработчики сами склонны выдумывать корнер-кейсы и придумывать, как с ними бороться. 
Причем хорошие корнер-кейсы смешиваются с откровенными фантазиями. Разработка усложняется, растет количество потенциальных багов и время разработки увеличивается.
Мне такое поведение разработчиков непонятно и я действую иначе. Оцениваю, какие могут возникнуть неучтенные моменты в новой фиче, оценить, можно ли пересмотреть подход, если краевые случаи будет тяжело поддерживать.

Это важный момент, который может оказывать влияние на разработку на долгой дистанции: менеджеры всегда хотят большего. 
И если им в этом потакать, то мы получим вообще неконтролируемый рост сложности системы с гибкой настройкой со стороны бекендов/разных CMS, что приведет вообще к отсутствию строгой верификации на клиенте.

В процессе делания занятия заинтересовала идея с выносом в отдельные классы/функции пограничных случаев с описанием происходящего. Постараюсь применить на рабочем проекте.
Особенность - мы точно знаем, где у нас расположены абстракции по работе с пограничными случаями. А значит мы сможем, при необходимости, работать с ними особым образом, добавлять на них метрики сложности, оценивать влияние на основную часть фичи.



