### 2. Пример LSP в тестах

первый пример из проекта: 
```kotlin
open class TokenUpdater(
    private val analytics: Analytics
) {

    open fun updateToken() {
        analytics.logEvent("token_update", "params")
    }
}

class ApiTokenUpdater(
    private val api: NetworkApi,
    analytics: Analytics,
) : TokenUpdater(analytics) {

    override fun updateToken() {
        super.updateToken()
        // Уточнение реализации родительского класса
    }
}

interface Analytics {
    fun logEvent(name: String, paramsJson: String)
}

//// тесты

abstract class TokenUpdaterTests<T : TokenUpdater> {

    @Mock
    lateinit var analytics: Analytics

    abstract fun createInstance(): T

    @Before
    fun setUp() {
        MockitoAnnotations.initMocks(this)
    }

    @Test
    fun `test token update logs event correctly`() {
        val updater = createInstance()
        updater.updateToken()

        // Проверяем, что метод logEvent был вызван
        Mockito.verify(analytics).logEvent("token_update", "params")
    }
}

class TokenUpdaterTest : TokenUpdaterTests<TokenUpdater>() {
    override fun createInstance() = TokenUpdater(analytics)
}

class ApiTokenUpdaterTest : TokenUpdaterTests<ApiTokenUpdater>() {

    @Mock
    lateinit var networkApi: NetworkApi

    override fun createInstance() = ApiTokenUpdater(networkApi, analytics)
}
```

второй пример не из проекта:

```kotlin
open class Vehicle {
    open fun startEngine(): String = "Engine started"
}

class Car : Vehicle() {
    override fun startEngine(): String = "Car engine started"
}

class Bike : Vehicle() {
    override fun startEngine(): String = "Bike engine started"
}

abstract class VehicleTests<T : Vehicle> {

    abstract fun createInstance(): T

    @Test
    fun `test start engine`() {
        val vehicle = createInstance()
        assertEquals("Engine started", vehicle.startEngine())
    }
}

class VehicleTest : VehicleTests<Vehicle>() {
    override fun createInstance() = Vehicle()
}

class CarTest : VehicleTests<Car>() {
    override fun createInstance() = Car()
}

class BikeTest : VehicleTests<Bike>() {
    override fun createInstance() = Bike()
}
```

### 3. Примеры полиморфизма подтипов

Да, я придерживаюсь полиморфизма подтипов как основного случая, когда наследование действительно полезно. 
В нашем проекте по управлению умным домом мы часто сталкиваемся с ситуациями, где необходимо работать с различными устройствами, имеющими общие характеристики и поведение.

Пример 1: Соблюдение правила при использовании наследования для полиморфизма подтипов

Сценарий:

В проекте у нас есть базовый класс Device (Устройство), который содержит общие для всех устройств методы и свойства:

- connect(): Подключение к сети
- disconnect(): Отключение от сети
- getStatus(): Получение текущего статуса

От этого класса наследуются различные устройства:

- SmartLight (Умная лампа)
- SmartThermostat (Умный термостат)
- SecurityCamera (Камера наблюдения)

Мы создаём функцию updateDevices(List<Device> devices), которая принимает список устройств и обновляет их прошивку или конфигурацию.

В данном случае наследование используется правильно, потому что:

- Мы создаём экземпляры как базового класса Device, так и его подклассов
- Мы передаём эти экземпляры в функции, ожидающие тип Device
- Полиморфизм позволяет нам вызывать специфические переопределённые методы для каждого устройства в общей функции

Пример 2: Один из примеров осознанных нарушений полиморфизма видел в коде Kotlin, а именно функция `fastForEach`.
Скорость достигается за счет отказа от использования итератора в сторону произвольного доступа к элементам списка.
Но отнюдь не все структуры данных поддерживают произвольный доступ к элементам, поэтому на таких структурах функция работать просто не будет.

Это сказано в спецификации к функции и является примером, когда дочерние и родительские типы не являются равноправными. 
Хотя надо сказать, что пример касается реализации интерфейса, например, `List`.

Пример 3: Нарушение правила при использовании наследования без необходимости в полиморфизме

Сценарий:

В проекте есть классы UserSettings (Настройки пользователя) и AppTheme (Тема приложения). Разработчик решил сделать AppTheme подклассом UserSettings, чтобы получить доступ к некоторым общим методам настройки.

```kotlin
open class UserSettings {
    
    fun saveSettings() {
        // реализация..
    }
    
    fun loadSettings() {
        // реализация
    }
}

class AppTheme : UserSettings() {
    
    fun applyTheme() {
        //
    }
}
```

Здесь наследование используется неправильно, потому что:

- AppTheme не является подтипом UserSettings; тема приложения не является видом настроек пользователя
- Мы не передаём экземпляры AppTheme в функции, ожидающие UserSettings, полиморфизм не используется
- Цель наследования здесь - повторное использование кода, но это можно было достичь с помощью композиции.

Лучше было бы:

- Использовать композицию: включить экземпляр UserSettings в AppTheme.
- Избежать неверного отношения "является" и придерживаться принципа единой ответственности.


### Выводы

В процессе выполнения задания по предоставлению примеров соблюдения и нарушения правила использования наследования только при необходимости полиморфизма подтипов, я получил возможность глубже осмыслить принципиальные аспекты ООП и их влияние на качество архитектуры программного обеспечения.

1. Понимание сущности наследования и полиморфизма

Подготавливая примеры, я еще раз убедился, что наследование это не просто способ повторного использования кода, а инструмент для установления иерархических отношений между сущностями, отражающих реальные взаимосвязи.
На самом деле, по опыту, в проектах довольно редко приходится видеть созданную иерархию наследования, тем более превышающую глубину 2. 
Отсюда вытекает следующий пункт:

2. Пример подчеркнул, что часто композиция и использование интерфейсов являются более правильным выбором по сравнению с наследованием. 
Это позволяет создавать гибкие и легко модифицируемые системы, где компоненты можно заменять или изменять без влияния на остальные части системы. 
Интерфейсы устанавливают контракт поведения, а композиция позволяет использовать нужную функциональность без жесткой привязки к иерархии классов.

3. Также, принимая во внимание возможность без особых опасений передавать подтипы в функции, ожидающие супертип, помогает в рассуждении того, насколько равны между собой типы, это позволяет проверить созданную иерархию на прочность и, возможно, пересмотреть ее структуру. По крайней мере появляются нужные мысли и открываются новые связи при ревизии иерархии.

Общие мысли:

Выполнение этого задания позволило мне еще раз убедиться в важности правильного выбора инструментов и подходов при проектировании систем. 
Осознанное применение наследования и других механизмов ООП напрямую влияет на качество программного обеспечения, его надежность и пригодность к изменениям. 
В современных проектах, где требования могут быстро меняться, гибкость архитектуры становится ключевым фактором успеха.
