### 1

```kotlin
class TemperatureSensor {
    fun read(): Double = currentTemperature  // предполагается, что температура всегда актуальна
}

class HeatingController(private val sensor: TemperatureSensor) {
    fun regulate() {
        if (sensor.read() < 20.0) enableHeating()
    }
}
```

При работе с датчиками и другими частоизменяемыми данными опасно просто прочитать текущее значение.
Оно в скором времени может измениться и данные будут неактуальны.
Даже в стандартной библиотеке android по работе с сетью есть плохо спроектированный api, который позволяет читать текущее значение сети (а оно могло уже измениться).
Поэтому там куча таких методов помечены Deprecated и нужно использовать модель подписки.

### 2

```kotlin
// Объект-синглтон для хранения данных о текущем пользователе
object UserManager {
    var currentUser: User? = null // Изменяемое общее состояние!

    fun login(user: User) {
        this.currentUser = user
    }

    fun logout() {
        this.currentUser = null
    }
}

class ProfileViewModel {
    // Функция неявно зависит от глобального состояния UserManager
    fun getGreetingMessage(): String {
        val userName = UserManager.currentUser?.name ?: "Гость"
        return "Добро пожаловать, $userName!"
    }
}
```

Глядя на функцию getGreetingMessage() в изоляции, 
вы не можете с уверенностью сказать, что она вернет. 
Ее результат полностью зависит от того, был ли где-то в другом месте приложения вызван метод UserManager.login().

### 3

```kotlin
class AnalyticsTracker {
    private lateinit var apiKey: String

    // Метод, который нужно вызвать первым
    fun configure(apiKey: String) {
        this.apiKey = apiKey
        println("Аналитика сконфигурирована")
    }

    // Метод для отправки события
    fun trackEvent(eventName: String) {
        // Эта строка упадет, если configure() не был вызван ранее
        if (!::apiKey.isInitialized) {
            println("Ошибка: трекер не сконфигурирован!")
            return
        }
        println("Отправка события '$eventName' с ключом $apiKey")
    }
}

// Использование
val tracker = AnalyticsTracker()
tracker.trackEvent("app_opened") // тут будет ошибка: аналитика не сконфигурирована
```

Здесь популярная ошибка, что есть некий сервис, который нужно проинициализировать/сконфигурировать.
Для инициализации делат отдельное поле, потом требуется отправить аналитику при старте приложения и здесь уже важно следить за порядком инициализации компонент.
Нельзя просто отправить событие, необходимо учитывать дополнительные факторы.

### Выводы

Выполнение этого задания стало отличной возможностью для глубокой рефлексии о принципах качественного кода. 
Систематизация знаний о том, как одна из фундаментальных ошибок проектирования проявляется на практике. 
Я смог укрепить понимание, почему так важно следовать подходам с явным указанием спецификаций, предусловий и связях с другими частями системы.
Такой подход не исключает возможность ошибки, но повышает степень надежных гарантий, если это еще и выражено явными типами с проверкой допустимых значений.

Особенно показательным был пример с временной связанностью, так как эта ошибка гораздо менее очевидна, чем использование глобальных переменных.
Такие плохие примеры можно видеть и в стандартных sdk.  