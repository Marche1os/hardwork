Рассмотрим 3 популярные библиотечные зависимости в типичном Android проекте и одну "контролируемую" зависимость от собственной SDK:

1. Retrofit (сетевая библиотека для обмена данными по HTTP)
    - Семантика: Интерфейсный ориентированный подход, автоматическая сериализация данных, поддержка синхронных и асинхронных запросов
        - Дополнительные характеристики:
            1. Встроенные конвертеры для преобразования JSON
            2. Интегрированные с корутинами и Rx возвращаемые типы. Например, Observable<T>
            3. Удобное добавление интерцепторов для мониторинга запросов
    - Ключевые свойства: Масштабируемость, надежность, удобство внедрения и использования
    - Пространство допустимых изменений: Дополнительные изменения, которые расширяют, но не нарушают существующий функционал. Изменения, затрагивающие семантику сериализации или интерфейсы вызовов, должны быть минимальными и подразумевать наличие миграционного пути
    - Супер-спецификация: Обновления должны поддерживать ту же структуру для запросов HTTP и не должны требовать изменения в базовом коде клиента при смене версии.

2. Glide (библиотека для загрузки и кэширования изображений)
    - Семантика: Эффективная загрузка изображений, кэширование с оптимизацией использования памяти, обработка жизненного цикла View-компонента
        - Дополнительные характеристики:
            1. Автоматическое управление жизненным циклом изображений
            2. Поддержка различных форматов изображений и трансформаций
            3. Управление качеством и размером изображений
    - Ключевые свойства: Высокая производительность, низкое потребление ресурсов
    - Пространство допустимых изменений: Обновления не должны существенно влиять на алгоритм кэширования или политику очистки кэша, чтобы не нарушать производительность приложений и обратную совместимость.
    - Супер-спецификация: Подгрузка изображений должна оставаться незаметной для конечного пользователя при переходе на новые версии библиотеки

3. Провайдер авторизации
    - Семантика: Предоставление формы авторизации (через вебвью) с последующим редиректом в приложение и передачей токенов авторизации.
      - Дополнительные характеристики:
        1. Легкая интеграция с любым клиентским приложением
        2. Поддержка концепции "легкий клиент", вся тяжелая логика авторизации лежит централизованно на провайдере
        3. Информативные сообщения об ошибках и отсутствие необходимости в оборачивании API-вызовов в блоки try-catch 
    - Ключевые свойства: Безопасная авторизация, удовлетворение международным стандартам безопасности приложений, где есть оплата
    - Пространство допустимых изменений: Любые изменения, не затрагивающие клиента

4. Firebase Cloud Messaging (сервис для пуш-уведомлений)
    - Семантика: Надежная доставка сообщений на различные платформы и устройства, поддержка передачи данных в реальном времени, гибкость в настройке уведомлений
        - Дополнительные характеристики:
            1. Защита от "толстого пальца" (термин из инвестиций, означает непреднамеренное нажатие кнопки)
            2. Создание очередей рассылок
            3. Гибкие опции таргетинга и динамика рассылки
    - Ключевые свойства: Высокая доставляемость, низкая латентность, гибкость интеграции.
    - Пространство допустимых изменений: Любые изменения в API должны быть совместимы с предыдущими версиями для охраны существующих реализаций и процессов обработки уведомлений.


**Выводы.**

Недавно пришел к выводу, что разработка для программистов, куда относится и создание любого API, и создание подключаемых библиотек и модулей, которыми будут пользоваться программисты, требует гораздо большей адекватности и навыков проектировании, чем в настоящий момент имеют разработчики таких компонент.
Сплошь и рядом случаются ситуации, когда обновление версии библиотеки ломает и сборку проекта, и меняет привычное поведение подключаемого кода, незаметное на первый взгляд. Даже в стандартных SDK находятся сотни и тысячи "устаревших" функций и классов, использование которых не рекомендуется.

Выполняя текущее задание, можно сказать "контроля за системой много не бывает", в том смысле, что есть разница между зависимостью от библиотеки компании X, и от библиотеки, созданной в стенах твоего офиса. 

Также знания, полученные на задании, наталкивают на создание ответственного на проекте за контроль зависимостей. Создание такой концепции, как "Dependency train", означающие постоянное и плавное повышение версий зависимостей, долгосрочно позволяют сделать процесс резолва зависимостей более быстрым и предсказуемым.
Внедрение стратегии управления зависимостями может значительно уменьшить риск технического долга и упростить процесс обновления программного обеспечения. 