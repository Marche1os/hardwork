### 1

```kotlin
interface ScreenContext {
    
    fun showSnackbar(text: String)
    
    fun sendNavigationEvent(event: (Router) -> Unit)
    
    val forceUpdateFlow: Flow<Boolean>
}
```

Это пример интерфейса, который может быть разделен на несколько.
ScreenContext реализует экран, который имеет доступ к окружению. 
Но сейчас от экрана требуется реализовывать ряд методов, которые для конкретного случая, возможно, не нужны.

В качестве альтернативы можно либо разделить на более мелкие интерфейсы, либо перейти на подход обмена сообщениями:

```kotlin
sealed interface Message

data class SnackbarMessage(val text: String): Message

interface ScreenContext {
    
    fun send(message: Message)
}
```

### 2
```kotlin
interface LocationService {
    fun startLocationUpdates()
    
    fun stopLocationUpdates()
    
    fun getCurrentLocation()
    
    fun calculateRoute(latLon: LatLon): Route
}
```

Данный интерфейс тянет за собой необходимость реализовывать расчет маршрута.
Как решения можно сделать 3 интерфейса, тем самым избавив класс-реализацию от необходимости реализовывать все методы.

### 3

```kotlin
interface AuthStorage {
    
    fun readAuthToken(): String
    
    fun readRefreshToken(): String
    
    fun writeAuthToken(token: String)
    
    fun writeRefreshToken(refreshToken: String)
    
    fun clear()
}
```

В этом интерфейсе нарушение SRP и ISR, так как требует от класса-имплементации `AuthStorage` полной реализации всех методов.

В качестве решения можно выделить `ReadOnlyAuthStorage`, `ReadWriteAuthStorage` и интерфейс очистки хранилища.

### Выводы

В ходе выполнения работы я проанализировал несколько мест и выявил, где изначальная структура интерфейсов нарушала принципы SRP и ISP. 
Рефакторинг заключался в разделении "тяжёлых" интерфейсов на целевые и более обобщенные контракты.

Основные выводы

- Часто в реальных проектах интерфейсы создаются с учетом будущих изменений и включают функционал, который некоторым реализациям не нужен. Это напрямую нарушает ISP.
- Разделение интерфейсов по одной цели (SRP для интерфейсов) не только минимизирует лишние зависимости, но и улучшает читаемость кода.
- После декомпозиции интерфейсов методы становятся легче тестировать, а внедрение зависимостей становится легче.

Interface Segregation Principle предполагает, что клиенты интерфейсов должны зависеть только от тех методов, которые они действительно используют. 
В Android разработке это особенно актуально из‑за:

- разнообразия модулей (UI, сеть, база данных), которые часто пересекаются, но не должны тянуть лишний код,
- частой работы с ограниченными ресурсами - ненужные зависимости ведут к росту объёма сборки, усложнению тестирования и повышенной связанности.