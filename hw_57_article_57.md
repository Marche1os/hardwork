### 1. Какое-то кеширование

Например, любое in-memory кеширование. 
Обычно кеширование мы делаем для конкретного кейса, поэтому и типы данных используются конкретные, как в примере ниже.

```kotlin
class EventsInMemoryCacheImpl : EventsInMemoryCache {

    @Volatile
    private var event: Event? = null
    private val lock = Any()

    override fun put(event: Event) {
        synchronized(lock) {
            this.event = event
        }
    }
    override fun get(): Event? {
        return event
    }
}

interface EventsInMemoryCache {

    fun put(event: Event)

    fun get(): Event?
}
```

Однако подобный механизм легко расширить до работы с любыми типами данных, соответственно удовлетворять он будет любым интерфейсам, предполагающим сохранение и получение некоего элемента.
И кстати, здесь также есть сходства с интерфейсов для, например, АТД Stack. :)

### 2 Про модули с подходом api/impl

На проекте следующая структура модулей: модули разделены на Api- и Impl-модули.
Api представляет собой интерфейс, который предоставляет модуль, а Impl соответственно реализацию интерфейса и внутренняя логика, которая скрыта.
В таком подходе мы можем управлять областью видимости, помещая сущности в api/impl модуль.
Кроме этого, можно, в целом, организовать архитектуру таким образом, чтобы в проекте были такие api модули, которые бы легко заменялись на уровне impl модуля.

Например, есть разные виды авторизации. Пусть будет AuthGithub и AuthGoogleId. И impl модуль может реализовывать разные api модули в зависимости от ситуации.
Если нужно реализовать другой вид авторизации, достаточно будет для impl модуля указать другой api модуль.
Но это, конечно, требует большую работу по организации подобной архитектуры.

### 3 Downloader APK файлов

Есть загрузчик APK файлов, который:
- Вне жизненного цикла приложения загружает файл в cache директорию;
- Проверяет сигнатуру и целостность загруженного файла;
- Отправляет аналитику и логирует ход загрузки, успех/неудачу загрузки и проверку целостности.

Реализация относится к загрузке именно APK файлов и есть функция проверки, что загруженный файл - это новая версия приложения.
Однако можно добавить "конфигуратор" к такому загрузчику, чтобы расширить назначение класса и до других кейсов.
Например, для загрузки тяжелых изображений или персонажей для голосового ассистента. 
Через конфигуратор могут настраиваться расширения файлов, логику проверки файлов и т.д.

### Выводы

Во всех трех случаях объединение функциональностей в одном классе значительно облегчили поддержку и расширение программного продукта. 
Однако, важно также сохранять баланс и не допускать чрезмерного усложнения классов, 
чтобы избежать проблем с читаемостью и поддерживаемостью кода.

С другой стороны открыл для себя новую технику размышления о коде "снизу-вверх". То есть от реализации к интерфейсам.
Такая техника помогает расширить область понимание кодовой базы и находить новые способы решения задач, избавляться от дублирования кода и в целом лучше оперировать компонентами системы.

В процессе выполнения задания увлекся чтением работ Харпера, нашел множество идей, выходящих за рамки задания по модулям.
Интересны идеи о том, что начинать изучать (и преподавать) программирование эффективнее не по принципу "от железа к высоким уровням абстракции", а с выражения кода, по-сути, на языке математики. 
В этом помогает функциональное программирование.

