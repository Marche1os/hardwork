1. Репозитории с разными источниками данных (локальные и удаленные)

Пример:

```kotlin
interface UserRepository {  
    fun getUser(id: String): User  
}

class RemoteUserRepository : UserRepository {
    override fun getUser(id: String) = fetchUserFromNetwork(id)
}

class LocalUserRepository : UserRepository {
    override fun getUser(id: String) = fetchUserFromDatabase(id)
} 
```

Код, который использует UserRepository, работает одинаково с любым его подклассом: он не зависит от того, откуда берутся данные - локально или удаленно. 
Это классическая подстановка, когда можно заменить интерфейс на любой подкласс без изменения поведения.

2. View-модели с общим интерфейсом для разных экранов

Пример:

```kotlin
interface BaseViewModel {  
    val state: StateFlow<State>  
}

class LoginViewModel : BaseViewModel { 
    // ...
}  
class ProfileViewModel : BaseViewModel { 
    // ...
} 
```

UI-компоненты могут работать с любым BaseViewModel, не зная деталей конкретной реализации. 
Это позволяет менять ViewModel без нарушения работы UI, подставляя более конкретный класс.

3. Класс Command pattern для разных операций UI

Пример:

```kotlin
interface Command {  
    fun execute()  
}

class SaveCommand : Command {  
    override fun execute() { saveData() }  
}

class DeleteCommand : Command {  
    override fun execute() { deleteData() }  
}  
```

Клиентский код вызывает execute() на Command и ожидает корректное поведение вне зависимости от конкретного типа команды, 
без изменения клиентского кода. 

4. Состояния UI, реализованные через sealed class

Пример:

```kotlin

sealed class UiState {
    data object Loading : UiState()  
    data object Error : UiState()
    
    data class Content(val data: List<Item>) : UiState()  
}  

```

Функции, обрабатывающие UiState, могут принимать любое состояние-наследник без нарушения логики, 
гарантируя универсальность и предсказуемость - подстановка конкретного подкласса UiState работает без сбоев.

5. Маппинг данных

```kotlin
fun interface Mapper<T, R> {  
    fun map(value: T): R  
}  

fun <T, R> transform(items: List<T>, mapper: Mapper<T, R>): List<R> =  
    items.map { mapper.map(it) }  
```

Использование интерфейсов с одним методом (SAM) позволяет заменять конкретные реализации, не меняя поведение всей цепочки. Например, Predicate<T>, Mapper<T, R> и т.п. При этом любая реализация должна поддерживать контракт. Это естественное соблюдение LSP.

### Выводы

Выполнение задание помогло глубже понять, как данный принцип проявляется в ФП. 
Мне стало ясно, что соблюдение контрактов и предсказуемого поведения функций играет ключевую роль в построении надежного кода. 
Особенно интересно, как использование типов с ограниченным наследованием и неизменяемых данных упрощает поддержку LSP, делая систему более устойчивой к изменениям.

Многие разработчики знают про принципы SOLID и в частности про LSP, но все равно находятся баги, возникшие в результате нарушения одного из принципов.
В случае LSP был баг, когда в цепочке наследования осуществлялись вызовы с побочными эффектами, приводившими к падению приложения из-за неконсистетности состояния при инициализации базовых и дочерних классов.
В свою очередь использование чистых функций и неизменяемых структур данных минимизирует побочные эффекты, что очень важно для надежности и предсказуемости работы приложений.
