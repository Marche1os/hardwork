### 1. Кеширование баннеров

Какое-то время фильтрация скрытых пользователем рекламных баннеров производилась на клиенте. 
И для определения того, был ли скрыт баннер, изначально использовалось булево поле в БД SqlLite.
В дальнейшем появилось требование снова показывать баннер, если прошло определенное время. 
Так добавилось и поля с временем скрытия баннера и отсчетом времени.
Даже до появления такого требования можно было использовать поля - время скрытия баннера (timestamp).

### 2. Онбординг устройств в комнате

В этом проекте на клиенте производится логика предложения пройти онбординг устройства в зависимости от наличия нужных устройств.
Такой онбординг можно скрыть и факт скрытия также определяется через булево свойство.
Пока не было необходимости понимать момент, когда онбординг был скрыт, но появление такой потребности вполне реалистично.
Например, чтобы напоминать о возможности устройств или выстраивать политики "бесячести" подобного скрываемого контента.
Поэтому для такого проекта рекомендация использовать временные метки подходит.

### 3. Всплывающие шторки

Сейчас во многих приложениях используются всплывающие шторки для каких-либо коммуникаций (рекламы, запрос разрешений, онбординг и т.д.) и их становится так много, что требуется уже определять время показа конкретных шторок, чтобы сильно не раздражать пользователей.
Для такого рода фичи потребуется использовать временные метки вместо простого логического свойства "показ шторки".

### Заключение

Рассмотрены проекты в контексте Android разработки. 
Как можно заметить, многим фичам использование временных меток помогает сделать контент менее навязчивым и улучшает пользовательский опыт.
Из чего можно сделать вывод, что подобные "скрываемые" фичи или проекты, привносящие в приложение рекламу и другую "навязчивость", хорошие кандидаты на то, чтобы использовать временные метки вместо булевых значений.
Использую данный вывод в дальнейших проектах, как рабочих, так и личных.

Таким образом, переход от простого логического поля к использованию временных меток позволяет более гибко управлять показом контента. 
Это позволяет не только скрывать или снова показывать элементы по истечении определенного времени, но и выстраивать более сложные стратегии взаимодействия, такие как напоминания пользователям или управление "бесячестью" интерфейса.


