### Зависимость фреймворка
Пример с конфигурационным файлом платформы Firebase Config от Google. 
Опишу вкратце схему работы. Через веб-интерфейс задается создается и редактируется некая конфигурация, которую получает клиентское приложение.
В целом, все работает хорошо, однако у решения от Google есть свойство, из-за которого мы вынуждены признать, что работоспособность всего приложения зависит от фреймворка.
Свойство такое, что Google не поддерживает согласованность кешей на всех серверах, из-за чего данные на клиент могут приходить отличными от тех, что заданы в конфиге.

Решение комплексное прорабатывается, будет заключаться в переводе решения на собственные сервера, что позволит нам влиять на характеристики работы данного механизма.

### Зависимость расшаренного формата.
Представим, что приложение для управления умным домом обновляется и добавляется новая функциональность для управления умными замками. 
Это требует обновления формата данных, передаваемого между приложением и сервером. 
При обновлении приложения разработчики модифицировали формат JSON, добавив новые поля, относящиеся к управлению замками. Однако сервер еще не обновлен для поддержки этого нового формата. Это приводит к тому, что данные, отправляемые приложением, не могут быть правильно интерпретированы сервером, вызывая сбои в работе приложения и потерю функциональности.

**Решение.** 
Существуют плагины, которые из заданного JSON формируют DTO объекты.
В компании принят подход монорепозитория. Все команды разрабатывают в рамках одного репозитория. 
Это позволило создать собственное решение, гарантирующее правильность сериализации и десериализации JSON между клиентом и сервером.

### Зависимость зависимости.
Пример проблемы:

До Java 8, класс HashMap в Java использовал связанный список для разрешения коллизий. 
Однако в Java 8 было принято решение оптимизировать производительность HashMap путем изменения структуры данных для хранения элементов с связанных списков на сбалансированные деревья для корзин с большим количеством элементов. 
Это значительно улучшило производительность в случаях, когда происходили коллизии.

Потенциальные проблемы:

Разработчики, которые неосознанно полагались на порядок обхода элементов в HashMap (например, последовательность, в которой элементы были добавлены), могли столкнуться с проблемой, так как изменение структуры данных затрагивает порядок итерации. 
Хотя HashMap и не гарантирует определенный порядок элементов, в некоторых случаях разработчики могли использовать эту особенность в своем коде, что становится потенциальной точкой сбоя при переходе на Java 8 и выше, где порядок элементов при итерации стал другим из-за внутренних изменений.

На самом деле, на различных форумах и конференциях достаточно часто можно было встретить доклады, на которых делились опытом проблем, связанных с переходом.

Так же, насколько помню, функция интерфейсов с реализацией, дефолтные интерфейсы, могло сломать некоторые операторы в фреймворке Java Streams, когда тип интерфейсов использовался как значение в структуре данных,

**Решение.**
В нашей команде принят подход, при котором все зависимости помещаются в свой собственный репозиторий, а добавление в репозиторий проходит этапы контроля, включение скриптов поиска на уязвимости и ручное ревью.
Отчасти это помогает отловить ситуации, когда обновление библиотек может сломать клиентский код. В случае с версией языка, правда, сложнее, оно таким проверкам не подвержено.

### Зависимость краша.

На первой своей работе часто встречались краши, когда один модуль вызывал методы модуля Network и получал необработанный краш, который вызывал креш всего приложения.
Проблемой этого служило отсутствие спецификации при работе с сетевым слоем, отсутствовала спецификация у методов API.

В качестве решения был переезд на фреймворк RxJava.  
Когда метод возвращает некий источник данных, мы по-сути мы создаем контракт между вызывающим и вызываемым кодом и по требованию контракта обязаны явно указать, как будем работать с возникшей исключительной ситуацией, когда подписываемся на этот источник.


Вообще, видов крашей в Android весьма много. Есть типичные краши на уровне языка (например, NPE), есть краши, вызванные системой (например, попытка получить доступ к геопозиции без запроса разрешения).

При правильно выстроенной архитектуре, зависимость от первого вида крашей можно убрать. Один из способов, это реализация бизнес-логики на фреймворке RxJava, тогда каждый клиентский код обязан обрабатывать возможные ошибки. 

### Зависимость перебрасывания.

На прошлой работе из-за внешних факторов возникала угроза блокировки одного из Google сервисов по доставке пушей.
Чтобы часть функционала не зависел от одного компонента, был сделан fallback на альтернативный провайдер, который стоил дороже, а доставляемость пушей была меньше.

Таким образом, можно сказать, что функционал доставки пушей зависит от {Google Push service, fallback provider}.

### Зависимость инверсии.

Покажу как выстрелила проблема, когда проблема: предоставление зависимости сетевого клиента, возвращающего dto объекты, в виде конкретной создало проблемы при внедрении правктики написания интеграционных тестов.
Естественное решение, скрыть за слоем интерфейса сетевой клиент. В этом кейсе мы не отвязались от конкретной реализации, то есть зависимость от сетевого клиента осталась, но проблема с написанием тестов таким образом решилась.

### Зависимость зацикливания.

Конкретного примера с циклической зависимостью между модулями в Android проекте не назову. 
Почти все команды используют паттерн dependency injection, библиотеку Dagger, которая в compile-time проверяет циклические зависимости между зависимостями и роняет сборку в случае проблем.
Поэтому чаще думаем, как можно разрешить такую зависимость. Мы используем подход с api/impl модулями, когда у каждого модуля есть api, через который могут обращаться другие модули. И есть impl модуль, по-сути внутренняя реализация модуля. 

### Зависимость высшего порядка.

Прежняя реализация локального хранилища ключей не имела спецификации. Некоторые ключи при разлогине занулялись, некоторым присваивалось пустое значение. 
В вызывающем коде могли забыть сделать проверки. 
Решение: редизайн компонента, задание спецификаций, проверка предусловий при вызове изменяющих функций. Снижена зависимость от правильности работы вызывающего наш компонент кода.

### Зависимость большинства

Возьмем приложение, показывающее прогноз погоды. Для более точного прогноза используется сразу несколько источников, например, 5.
Однако для экономии ресурсов и времени, а также для предотвращения потенциальных противоречий в данных, приложение решает использовать в своих вычислениях данные только от тех сервисов, которые сходятся в своих прогнозах.
Приложение не зависит от любого конкретного сервиса прогнозирования погоды, но зависит от мнения большинства сервисов. Это создает сложную зависимость.

В качестве решения будет реализована система "голосования" между сервисами. 
При получении данных от каждого сервиса, приложение проверяет, достаточно ли сервисов пришли к согласию (например, 2 из 5). 


### Выводы.

По результатам выполнения задания научился разделять категории зависимости.

Разделим виды зависимостей на 2 категории: необходимые и необязательные.

**Необходимые** - это те зависимости, которые естественны для нашей системы. Например, драйвер, специальным образом работающий с технологией трассировки лучей конкретной линейки видеокарт от Nvidia. 
Такой пример должен и будет зависеть как от железа, так и от узкоспециализированного API. 
Покрой мы хоть луковым слоем абстракций работу с API, мы не уйдем от физической зависимости - и это нормально для такой категории зависимостей.

**Необязательные** по-сути представляют собой вспомогательные инструменты, упрощающие некоторые аспекты при работе внутри нашей системы.
Инструменты должны выбираться правильно, с учетом технических характеристик, надежности минимального используемого инструментария. Например, затаскивать библиотеку, увеличивающую размер приложения на мегабайты, ради 1-2 функций не выглядит разумным решением. 

По результатам выполненных заданий появилось понимание в принципе разных видов зависимостей. Что же это даст? 
Понимание зависимостей между компонентами системы позволяет проектировать архитектуру так, чтобы минимизировать связанность между модулями.

Также на одном из последних пулл-реквестов подсветил проблему расшаренного формата. 
Код из одной функции полагался на правильный порядок и формат работы другой функции в том же файле, между ними логически есть явная согласованность.
Осознание такой зависимости в целом обозначает существование потенциально проблемного места (бага), что уже должно помочь при нахождении оптимального и правильного решения, по которому можно сказать, решает оно зависимость и проблему или нет.

Вдобавок на следующий день после изучения темы изоморфизмов из СИ получилось применить это знание на практике, увидеть лишнюю операцию со списками на пулл-реквесте.   