### Логика Хоара

### 1

```kotlin

/**
 * Auth хранилище с возможностью записи.
 * Этот интерфейс должен использоваться только в модуле авторизации
 */
interface ReadWriteAuthStorage : ReadOnlyAuthStorage {

    /**
     * Предусловие: [token] содержит валидный JWT формат
     * Постусловие: токен сохранен в хранилище
     */
    fun writeRefreshToken(token: String)
}
```
Учет спецификаций в вызывающем коде не предусмотрен, соответствие токена формату JWT целиком на бекенде и на мобильном клиенте никак не верифицируется.

### 2

```kotlin
/**
 * Фильтрация устройств на главном экране. 
 * Отвечает за отбрасывание устройств в невалидном состоянии:
 * - Который не привязаны к дому;
 * 
 * Предусловие: непустой список устройств
 * Постусловие: список устройств, каждое из которых привязано к дому
 */
fun filterEmptyDevices(devices: List<Device>): List<Device>
```

В вызывающем коде происходит проверка на выполнение предусловия. Для пустого списка будет сразу отрисован пустой экран.

### 3
```kotlin
// DeviceListViewModel.kt

/**
 * Предусловие: [deviceId] не пустая строка
 * Постусловие: Устройство по [deviceId] находится в инвертированном состоянии от [currentIsOn]
 * Если произошла ошибка при смене состояния, то в стейт устройства вернется информация об ошибке
 */
fun onDeviceToggled(deviceId: String, currentIsOn: Boolean)
```

- Со стороны UI. UI просто сообщает: "Пользователь нажал на переключатель для устройства X". Он не пытается сам изменить свое состояние. Состояние переключателя (checked) напрямую привязано к device.isOn из uiState, который предоставляет ViewModel.
- Со стороны ViewModel. ViewModel принимает этот сигнал и выполняет всю работу: оптимистичное обновление, вызов UseCase, обработка результата.


### 4

```kotlin

/**
 * Функция маппит список [Scenario] в гридовое представление сценариев для отображения на UI
 * 
 * Предусловие: непустой список сценариев
 * Постусловие: сформированная из списка сетка заданной размерности
 */
fun mapScenariosToUiState(scenarios: List<Scenario>): ScenarioGrid
```
В вызывающем коде происходит проверка соответствия предусловию путем проверки списка на пустоту. 
По требованиям для пустого списка сценариев подготавливается специально заданные шаблоны сценариев и онбординг.

### 5

```kotlin

/**
 * Обновление параметров устройства в локальном кеше
 * 
 * Предусловие: обновляемое устройство присутствует в кеше
 * Постусловие: устройство обновлено
 */
suspend fun forceUpdateDevice(updatedDevice: Device): Boolean
```

Функция вызывается однократно для граничного случая, когда бекенд не может служить источником, и приходится делать force update в кеше.
После вызова функции происходит получение обновленного устройства с верификацией обновления (через assert).

### Выводы

С большим удовольствием делал задание, так как сейчас занимаюсь подготовкой статьи на тему создания надежной архитектуры в мобильном приложении.
Задание позволило найти новую важную информацию для статьи и для практического применения. 
За последний год я стал сторонником формального подхода и стараюсь использовать некоторые формальные методы, вроде явных спецификаций в коде, для повышения наглядности и надежности программы.

Также стараюсь прививать команде строгий подход к понятиям бага и корректности программ. Потому что часто случается, что есть спецификация, оформленная в вики, но эта спецификация быстро устаревает из-за новых договоренностей в чатах и не актуализируется.
Это приводит, конечно, к большему числу "багов", даже если все работает в соответствии с изначальной спецификацией.
В итоге - отсутствие единого источника правды и множество деталей, живущих в головах участников дискуссий (при этом, вероятно, довольно ограниченное время).

Особым вызовом при задании спецификаций какой-то функции являются вызовы других функций, ведь нужно учитывать их спецификации, а не только корректность результата для какого-то входного значения.

