### 1. Пример с сортировкой домов 
В приложении по управлению умным домом можно создать несколько домов, к которым будут привязаны устройства.
В процессе разработки сортировка на тестовых домах была ожидаемой. Но уже при выкатке фичи обнаружено, что порядок сортировки недетерминирован и отличается от запроса к запросу.
Такое поведение было не специфицировано. Но следовало уточнить, сортируется ли вообще список при отправке на клиент.

### 2. Ошибка с восстановлением состояния приложения
В Android, если при возврате в приложение требуется восстановить состояние, система сама восстанавливает цепочку экранов. Но разработчики одной библиотеки (хотя библиотека нашей компании, просто другой команды) не учитывали это поведение (не изучили документации и исходный код) и пытались восстанавливать вручную цепочку экранов, что приводило к повторным аллокациям. 

### 3. Непредвиденное поведение у фреймворка навигации
Относительно новый подход к навигации между экранами от Google содержит множество недокументированных особенностей, которые можно узнать только из чтения исходного кода.
Одна из таких, это попытка осуществить переход экран, который еще не фактически не отобразился, что ведет к исключительной ситуации.
Сценарий такой, если, например, быстро кликнуть 2+ раз на кнопку, по которой осуществляется переход, то приложение может упасть, если повторный клик осуществлен до завершения флоу с открытием экрана.

### Примеры исправления:

### 1.
Для гарантии порядка элементов, был создан собственный тип данных `SortedByDeviceNameDevices`, отвечающий за хранение списка элементов, отсортированных по имени устройства.

```kotlin
class SortedByDeviceNameDevices private constructor(val data: List<Device>) {
    companion object Factory {
        fun create(devices: List<Device>) = SortedByDeviceNameDevices(devices.sortedBy { it.deviceName })
    }
}

data class Device(
    val deviceName: DeviceName,
    val id: String,
    //...
)

@JvmInline
value class DeviceName(val value: String) : Comparable<DeviceName> {
    init {
        require(value.isNotEmpty() && value.first().isUpperCase())
    }

    override fun compareTo(other: DeviceName): Int {
        return value.compareTo(other.value)
    }

    override fun toString(): String {
        return value
    }
}
```

### 2.
Для такого случая была инкапсулирована в одном ответственном классе логика с переключением табов в приложении и добавлена спецификация.

```kotlin
interface TabsNavigationRouter {

    /**
     * предусловие: приложение стартует заново (не возврат в приложение и не восстановление)
     * постусловие: созданы корневые фрагменты, служащие табами в приложении
     */
    fun prepareTabs(fragmentManager: FragmentManager)

    /**
     * метод-индикатор, служит индикацией того, что приложение восстанавливает состояние. 
     * Фрагменты будут восстановлены системой, дополнительно вручную ничего с ними делать не нужно
     * постусловие: системой восстановлены фрагменты навигации
     */
    fun restoreState(state: Bundle)

    /**
     * предусловие: навигация осуществляется не на активный таб
     * постусловие: осуществлен переход на новый таб
     */
    fun navigateToTab(tab: Tab)
}
```

### 3. Исправление навигации 
Клик по кнопке возвращает результат операции. Если экран открыт - возвращается признак, что навигация завершена. Вызывающий код соответствующим образом реагирует на результат, как ему нужно.

```kotlin
private val navigationResultFlow: Flow<Map<Screen, NavigationResult>> = mutableFlow()

fun navigateToDetails(): NavigationResult {
    // проверка статуса навигации. 
}

sealed class Screen(screenId: Int) {
    data object Details(val screenId: Int) : Screen(screenId)
    
    //...
    
}

enum class NavigationResult {
    COMPLETED,
    ALREADY_EXECUTION,
    PENDING
}
```

**Выводы**

Итак, рассматриваемая проблема: отсутствие уверенности в поведении кода используемого в API, сторонних модулях и т.д. 
Помню, еще на лекциях по программированию упоминалось, что большая часть нашей работы будет заключаться в чтении документации и исходных кодов с целью понять, как все работает. Поэтому хочется надеяться, что определенный бекграунд в этом есть. 
С другой стороны, будто бы в современных реалиях чтение документации если и происходит, то довольно поверхностно, что ведет к различным ошибкам и багам из-за "неожидаемого" поведения. Порой, это я замечал и за собой, когда работа некоторого сложного стороннего кода не была понята до конца.

Поэтому главный урок из этого задания, это не предугадывать, как работает сторонний компонетн, не додумывать и не полагаться на здравый смысл, как оно должно быть. 
А в деталях уяснить все нюансы. Какие-то вопросы решаются добавлением спецификаций, какие-то требуют правок в реализации. Заметил, что одним из побочных эффектов от конкретизаций (например, когда мы хотим сказать, что порядок элементов не важен, поменяв тип на Set) может являться дополнительные способы для оптимизации скорости выполнения.

Кстати, одно из неявных эффектов от отказа от сторонних решений в пользу своих - это более глубокое понимание разрабатываемого решения. На деле, такое может сэкономить немало времени и денег для компании. 



