### Структуры данных

На проекте принят подход, при котором проект делится на слои, самый верхний слой - слой данных, это входная точка в приложение для данных.
В этом слое приосходит получение данных извне, сериализация/десериализация и парсинг в структуры данных проекта.

Конечно, DTO объекты, которые парсятся из JSON, состоит из одних примитивов. 
Но в процессе маппинга этих объектов в доменные сущности происходит верификация данных, проверка множества значений и создание доменных структур данных.

Конечно, на бекенде могли перепутать смысл одинаковых представлений данных (например, firstName и lastName) одного типа.

В проекте до появления продуктовых команд была плохая ситуация, когда новый функционал в мобильных приложениях создавался уже при готовом бекенде, поэтому наши структуры данных были подвязаны на бекенд, на Rest API.
Но с появлением команд ситуация изменилась, и новый API формируется исходя из модели данных клиентов.

### Построение REST API

1. У Google есть такая группа сервисов под названием Firebase, и в эту группу сервисов входит Realtime NoSQL база данных: Firebase Firestore. 
Во-первых, она позволяет перенести логику получения данных на клиент, клиент запрашивает конкретный документ (например, дома), из которого выбирает по заданным параметрам конкретную запись (конкретный дом).
Такой подход по крайней мере позволяет самостоятельно формировать структуры данных и не зависеть от бекендов. Однако по-сути это "база данных наружу", что подходит далеко не для всех классов приложений.  
2. Описание модели данных. Вместо работы с сущностями по идентификатору, можно подумать над схемой, при которой некая сущность, например, устройство умного дома, запрашивается по описательным атрибутам. Пример: находится в X доме, в Y комнате и является лампочкой.

**Выводы**

Как Android разработчику мне не приходится работать с ORM, но у нас есть Room, обертка над SQLite и который генерирует за нас SQL запросы. 
В масштабах типичного клиентского мобильного приложения неэффективность Room незаметна и в целом содержит больше плюсов.

Прочитал обе статьи про проблемы с ORM. Интересно, что я сам не задумывался о нарушении архитектурных принципов при работе с базами данных. 
Например, у меня на проекте был класс Storage, через который можно было читать и записывать значения в локальное хранилище. 
И я изменил этот Storage, сделав отдельные имплементации для чтения и записи (ReadOnlyStorage и ReadWriteStorage). 
Но по отношению к базам данных почему-то не задумывался, что изменяемость данные доступна повсеместно. В работе буду учитывать этот момент, у нас на проекте используется в небольшом объеме работа с локальной базой данных.